[{"name":"Bytes.Comparable","comment":" Comparable Bytes\n\n-- TODO: Because we rely on the sorting of the hex string,\n-- it is super important to check that we only use\n-- lower case letters, but no uppercase.\n\n@docs Bytes\n@docs Any, toAny\n@docs concat, chunksOf, width, isEmpty\n@docs empty, fromBytes, fromHex, fromHexUnchecked, fromText, fromU8\n@docs toBytes, toHex, toText, toCbor, toU8\n@docs jsonEncode, jsonDecoder\n@docs blake2b224, blake2b256, blake2b512\n@docs dummy, dummyWithPrefix, pretty\n\n","unions":[{"name":"Any","comment":" A catch-all phantom type for bytes.\n","args":[],"cases":[]},{"name":"Bytes","comment":" A custom `Bytes` type that is comparable with `==`.\n\nUseful as otherwise, the original `Bytes` type from `elm/bytes` package cannot be used to compare for equality with `==`.\nThe phantom type parameter `a` indicates what type of Bytes are stored.\n\n","args":["a"],"cases":[]}],"aliases":[],"values":[{"name":"blake2b224","comment":" Compute the Blake2b-224 hash (28 bytes) of the given bytes.\n","type":"Bytes.Comparable.Bytes a -> Bytes.Comparable.Bytes b"},{"name":"blake2b256","comment":" Compute the Blake2b-256 hash (32 bytes) of the given bytes.\n","type":"Bytes.Comparable.Bytes a -> Bytes.Comparable.Bytes b"},{"name":"blake2b512","comment":" Compute the Blake2b-512 hash (64 bytes) of the given bytes.\n","type":"Bytes.Comparable.Bytes a -> Bytes.Comparable.Bytes b"},{"name":"chunksOf","comment":" Break a Bytestring into a list of chunks. Chunks are of the given width,\nexcept the last chunk which is only _at most_ the given width.\n","type":"Basics.Int -> Bytes.Comparable.Bytes a -> List.List (Bytes.Comparable.Bytes a)"},{"name":"concat","comment":" Concatenate two bytes sequences.\n","type":"Bytes.Comparable.Bytes a -> Bytes.Comparable.Bytes b -> Bytes.Comparable.Bytes c"},{"name":"dummy","comment":" Helper function to make up some bytes of a given length,\nstarting by the given text when decoded as text.\n","type":"Basics.Int -> String.String -> Bytes.Comparable.Bytes a"},{"name":"dummyWithPrefix","comment":" Helper function to make up some bytes of a given length,\nstarting with the provided bytes.\n","type":"Basics.Int -> Bytes.Comparable.Bytes a -> Bytes.Comparable.Bytes b"},{"name":"empty","comment":" Create an empty Bytes object.\n","type":"Bytes.Comparable.Bytes a"},{"name":"fromBytes","comment":" Create a [Bytes] object from an elm/bytes [Bytes.Bytes].\n","type":"Bytes.Bytes -> Bytes.Comparable.Bytes a"},{"name":"fromHex","comment":" Create a [Bytes] object from a hex-encoded string.\n","type":"String.String -> Maybe.Maybe (Bytes.Comparable.Bytes a)"},{"name":"fromHexUnchecked","comment":" Same as [fromHex] except it does not check that the hex-encoded string is well formed.\nIt is your responsability.\n","type":"String.String -> Bytes.Comparable.Bytes a"},{"name":"fromText","comment":" Create a [Bytes] with some text encoded as UTF8.\n","type":"String.String -> Bytes.Comparable.Bytes a"},{"name":"fromU8","comment":" Create a [Bytes] object from individual U8 integers.\n","type":"List.List Basics.Int -> Bytes.Comparable.Bytes a"},{"name":"isEmpty","comment":" Check if this is empy.\n","type":"Bytes.Comparable.Bytes a -> Basics.Bool"},{"name":"jsonDecoder","comment":" JSON decoder for Bytes.\n","type":"Json.Decode.Decoder (Bytes.Comparable.Bytes a)"},{"name":"jsonEncode","comment":" JSON encoder for Bytes.\n","type":"Bytes.Comparable.Bytes a -> Json.Encode.Value"},{"name":"pretty","comment":" Helper function that convert bytes to either Text if it looks like text,\nor its Hex representation otherwise.\n","type":"Bytes.Comparable.Bytes a -> String.String"},{"name":"toAny","comment":" Convert any type of bytes to `Bytes Any`.\n","type":"Bytes.Comparable.Bytes a -> Bytes.Comparable.Bytes Bytes.Comparable.Any"},{"name":"toBytes","comment":" Convert [Bytes] into elm/bytes [Bytes.Bytes].\n","type":"Bytes.Comparable.Bytes a -> Bytes.Bytes"},{"name":"toCbor","comment":" Cbor encoder.\n","type":"Bytes.Comparable.Bytes a -> Cbor.Encode.Encoder"},{"name":"toHex","comment":" Convert [Bytes] into a hex-encoded String.\n","type":"Bytes.Comparable.Bytes a -> String.String"},{"name":"toText","comment":" Convert [Bytes] into a UTF8 String.\n","type":"Bytes.Comparable.Bytes a -> Maybe.Maybe String.String"},{"name":"toU8","comment":" Convert a given [Bytes] into a list of U8 integers.\n","type":"Bytes.Comparable.Bytes a -> List.List Basics.Int"},{"name":"width","comment":" Length in bytes.\n","type":"Bytes.Comparable.Bytes a -> Basics.Int"}],"binops":[]},{"name":"Bytes.Crc8","comment":" CRC-8 digests\n\n@docs Crc8, digest\n\n","unions":[{"name":"Crc8","comment":" Phantom type for a 1-byte CRC8 checksum.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"digest","comment":" Function for finding the CRC-8 digest of a given [`Bytes`].\n\nTaken from [Haskell's `crc` library](https://hackage.haskell.org/package/crc-0.1.1.1/docs/src/Data.Digest.CRC8.html#updateDigest8), this\nimplementation uses the table lookup optimizatino for finding the digest.\n\n","type":"Bytes.Comparable.Bytes a -> Bytes.Comparable.Bytes Bytes.Crc8.Crc8"}],"binops":[]},{"name":"Bytes.Map","comment":" A `BytesMap` is a dictionnary mapping unique keys to values, where all keys are\nbyte strings.\n\nInsert, remove, and query operations all take O(log n) time.\n\n\n## BytesMaps\n\n@docs BytesMap\n\n\n## Build\n\n@docs empty, singleton, insert, update, remove\n\n\n## Query\n\n@docs isEmpty, member, get, size\n\n\n## Lists\n\n@docs keys, values, toList, fromList\n\n\n## Transform\n\n@docs map, mapWithKeys, foldl, foldlWithKeys, foldr, foldrWithKeys, filter, filterWithKeys\n\n\n## Combine\n\n@docs union, intersect, diff, merge\n\n\n## Encode / Decode\n\n@docs toCbor, fromCbor\n\n","unions":[{"name":"BytesMap","comment":" Dictionary mapping [Bytes] keys to values.\n","args":["k","v"],"cases":[]}],"aliases":[],"values":[{"name":"diff","comment":" Keep a key-value pair when its key does not appear in the second `BytesMap`.\n","type":"Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"empty","comment":" Create an empty `BytesMap`.\n","type":"Bytes.Map.BytesMap k v"},{"name":"filter","comment":" Keep only the values that pass the given test.\n","type":"(v -> Basics.Bool) -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"filterWithKeys","comment":" Keep only the key-value pairs that pass the given test.\n","type":"(Bytes.Comparable.Bytes k -> v -> Basics.Bool) -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"foldl","comment":" Fold over the values in a `BytesMap` from lowest key to highest key.\n","type":"(v -> result -> result) -> result -> Bytes.Map.BytesMap k v -> result"},{"name":"foldlWithKeys","comment":" Fold over the key-value pairs in a `BytesMap` from lowest key to highest key.\n","type":"(Bytes.Comparable.Bytes k -> v -> result -> result) -> result -> Bytes.Map.BytesMap k v -> result"},{"name":"foldr","comment":" Fold over the values in a `BytesMap` from highest key to lowest key.\n","type":"(v -> result -> result) -> result -> Bytes.Map.BytesMap k v -> result"},{"name":"foldrWithKeys","comment":" Fold over the key-value pairs in a `BytesMap` from highest key to lowest key.\n","type":"(Bytes.Comparable.Bytes k -> v -> result -> result) -> result -> Bytes.Map.BytesMap k v -> result"},{"name":"fromCbor","comment":" CBOR decoder.\n","type":"Cbor.Decode.Decoder v -> Cbor.Decode.Decoder (Bytes.Map.BytesMap k v)"},{"name":"fromList","comment":" Convert an association list into a `BytesMap`.\n","type":"List.List ( Bytes.Comparable.Bytes k, v ) -> Bytes.Map.BytesMap k v"},{"name":"get","comment":" Get the value associated with a key. If the key is not found, return `Nothing`. This is useful when you are not sure if a key will be in the `BytesMap`\n","type":"Bytes.Comparable.Bytes k -> Bytes.Map.BytesMap k v -> Maybe.Maybe v"},{"name":"insert","comment":" Insert a key-value pair into a `BytesMap`. Replaces value when there is a collision.\n","type":"Bytes.Comparable.Bytes k -> v -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"intersect","comment":" Keep a key-value pair when its key appears in the second `BytesMap`.\nPreference is given to values in the first `BytesMap`.\n","type":"Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"isEmpty","comment":" Determine if a `BytesMap` is empty.\n","type":"Bytes.Map.BytesMap k v -> Basics.Bool"},{"name":"keys","comment":" Get all of the keys in a `BytesMap`, sorted from lowest to highest.\n","type":"Bytes.Map.BytesMap k v -> List.List (Bytes.Comparable.Bytes k)"},{"name":"map","comment":" Apply a function to all values in a `BytesMap`.\n","type":"(a -> b) -> Bytes.Map.BytesMap k a -> Bytes.Map.BytesMap k b"},{"name":"mapWithKeys","comment":" Apply a function to all keys and values in a `BytesMap`.\n","type":"(Bytes.Comparable.Bytes k -> a -> b) -> Bytes.Map.BytesMap k a -> Bytes.Map.BytesMap k b"},{"name":"member","comment":" Determine if a key is in a `BytesMap`.\n","type":"Bytes.Comparable.Bytes k -> Bytes.Map.BytesMap k v -> Basics.Bool"},{"name":"merge","comment":" The most general way of combining two `BytesMap`. You provide three accumulators for when a given key appears:\n\n  - Only in the left `BytesMap`.\n  - In both `BytesMap`.\n  - Only in the right `BytesMap`.\n\nYou then traverse all the keys from lowest to highest, building up whatever you want.\n\n","type":"(Bytes.Comparable.Bytes k -> a -> result -> result) -> (Bytes.Comparable.Bytes k -> a -> b -> result -> result) -> (Bytes.Comparable.Bytes k -> b -> result -> result) -> Bytes.Map.BytesMap k a -> Bytes.Map.BytesMap k b -> result -> result"},{"name":"remove","comment":" Remove a key-value pair from a `BytesMap`. If the key is not found, no changes\nare made.\n","type":"Bytes.Comparable.Bytes k -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"singleton","comment":" Create a `BytesMap` with one key-value pair.\n","type":"Bytes.Comparable.Bytes k -> v -> Bytes.Map.BytesMap k v"},{"name":"size","comment":" Determine the number of key-value pairs in the `BytesMap`.\n","type":"Bytes.Map.BytesMap k v -> Basics.Int"},{"name":"toCbor","comment":" Cbor encoder.\n","type":"(v -> Cbor.Encode.Encoder) -> Bytes.Map.BytesMap k v -> Cbor.Encode.Encoder"},{"name":"toList","comment":" Convert a `BytesMap` into an association list of key-value pairs, sorted by keys.\n","type":"Bytes.Map.BytesMap k v -> List.List ( Bytes.Comparable.Bytes k, v )"},{"name":"union","comment":" Combine two `BytesMap`. If there is a collision, preference is given to\nthe first `BytesMap`.\n","type":"Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"update","comment":" Update the value of a `BytesMap` for a specific key with a given function.\n","type":"Bytes.Comparable.Bytes k -> (Maybe.Maybe v -> Maybe.Maybe v) -> Bytes.Map.BytesMap k v -> Bytes.Map.BytesMap k v"},{"name":"values","comment":" Get all of the values in a dictionary, in the order of their keys.\n","type":"Bytes.Map.BytesMap k v -> List.List v"}],"binops":[]},{"name":"Cardano.Address","comment":" Handling Cardano addresses.\n\n@docs Address, StakeAddress, NetworkId, ByronAddress\n\n@docs Credential, StakeCredential, StakeCredentialPointer, CredentialHash\n\n@docs fromString, fromBech32, fromBytes\n\n@docs enterprise, script, base, pointer\n\n@docs isShelleyWallet, extractNetworkId, extractCredentialHash, extractCredentialKeyHash, extractPubKeyHash, extractStakeCredential, extractStakeKeyHash\n\n@docs setShelleyStakeCred\n\n@docs Dict, emptyDict, dictFromList\n\n@docs StakeDict, emptyStakeDict, stakeDictFromList\n\n@docs networkIdFromInt\n\n@docs toBech32, toBytes, stakeAddressToBytes\n\n@docs toCbor, stakeAddressToCbor, credentialToCbor, encodeNetworkId\n\n@docs decode, decodeReward, decodeCredential\n\n","unions":[{"name":"Address","comment":" Full address, including the network ID.\n","args":[],"cases":[["Byron",["Bytes.Comparable.Bytes Cardano.Address.ByronAddress"]],["Shelley",["{ networkId : Cardano.Address.NetworkId, paymentCredential : Cardano.Address.Credential, stakeCredential : Maybe.Maybe Cardano.Address.StakeCredential }"]],["Reward",["Cardano.Address.StakeAddress"]]]},{"name":"ByronAddress","comment":" Phantom type for Byron addresses.\n","args":[],"cases":[]},{"name":"Credential","comment":" A general structure for representing an on-chain credential.\n\n[Credential] can represent both payment credentials or stake credentials.\n\nCredentials are always one of two kinds: a direct public/private key pair, or a script (native or Plutus).\n\n","args":[],"cases":[["VKeyHash",["Bytes.Comparable.Bytes Cardano.Address.CredentialHash"]],["ScriptHash",["Bytes.Comparable.Bytes Cardano.Address.CredentialHash"]]]},{"name":"CredentialHash","comment":" Phantom type for 28-bytes credential hashes,\ncorresponding either to VKey hashes or script hashes.\n\nThis is a Blake2b-224 hash.\n\n","args":[],"cases":[]},{"name":"NetworkId","comment":" The network ID of a transaction.\n","args":[],"cases":[["Testnet",[]],["Mainnet",[]]]},{"name":"StakeCredential","comment":" A StakeCredential represents the delegation and rewards withdrawal conditions associated with some stake address / account.\n\nA StakeCredential is either provided inline, or, by reference using an on-chain pointer.\nRead more about pointers in CIP-0019 :: Pointers.\n\n","args":[],"cases":[["InlineCredential",["Cardano.Address.Credential"]],["PointerCredential",["Cardano.Address.StakeCredentialPointer"]]]}],"aliases":[{"name":"Dict","comment":" Convenient alias for a `Dict` with [Address] keys.\nWhen converting to a `List`, its keys are sorted by address.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","args":["a"],"type":"Dict.Any.AnyDict String.String Cardano.Address.Address a"},{"name":"StakeAddress","comment":" An address type only use for things related to staking, such as delegation and reward withdrawals.\n","args":[],"type":"{ networkId : Cardano.Address.NetworkId, stakeCredential : Cardano.Address.Credential }"},{"name":"StakeCredentialPointer","comment":" A stake credential pointer.\n\nThis should not be used and is only present for compatibility with previous eras.\n\n","args":[],"type":"{ slotNumber : Basics.Int, transactionIndex : Basics.Int, certificateIndex : Basics.Int }"},{"name":"StakeDict","comment":" Convenient alias for a `Dict` with [StakeAddress] keys.\nWhen converting to a `List`, its keys are sorted by stake address.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","args":["a"],"type":"Dict.Any.AnyDict ( Basics.Int, String.String ) Cardano.Address.StakeAddress a"}],"values":[{"name":"base","comment":" Create a base address with a payement credential and a stake credential.\n","type":"Cardano.Address.NetworkId -> Cardano.Address.Credential -> Cardano.Address.Credential -> Cardano.Address.Address"},{"name":"credentialToCbor","comment":" CBOR encoder for a [Credential], be it for payment or for stake.\n","type":"Cardano.Address.Credential -> Cbor.Encode.Encoder"},{"name":"decode","comment":" CBOR decoder for [Address].\n","type":"Cbor.Decode.Decoder Cardano.Address.Address"},{"name":"decodeCredential","comment":" Decode [Credential] which is either from a key or a script.\n","type":"Cbor.Decode.Decoder Cardano.Address.Credential"},{"name":"decodeReward","comment":" CBOR decoder for [StakeAddress].\nThis only succeeds for a valid [Address] of the [Reward] variant.\n","type":"Cbor.Decode.Decoder Cardano.Address.StakeAddress"},{"name":"dictFromList","comment":" Create an address dictionary from a list.\nFor other operations, use the `AnyDict` module directly.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"List.List ( Cardano.Address.Address, a ) -> Cardano.Address.Dict a"},{"name":"emptyDict","comment":" Initialize an empty address dictionary.\nFor other operations, use the `AnyDict` module directly.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"Cardano.Address.Dict a"},{"name":"emptyStakeDict","comment":" Initialize an empty stake address dictionary.\nFor other operations, use the `AnyDict` module directly.\n\nThe keys order are derived from Haskell auto-derived credential order.\nMeaning Script first, then VKey.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"Cardano.Address.StakeDict a"},{"name":"encodeNetworkId","comment":" CBOR encoder for [NetworkId].\n","type":"Cardano.Address.NetworkId -> Cbor.Encode.Encoder"},{"name":"enterprise","comment":" Create a simple enterprise address, with only a payment credential and no stake credential.\n","type":"Cardano.Address.NetworkId -> Bytes.Comparable.Bytes Cardano.Address.CredentialHash -> Cardano.Address.Address"},{"name":"extractCredentialHash","comment":" Extract the credential hash (either key hash or script hash).\n","type":"Cardano.Address.Credential -> Bytes.Comparable.Bytes Cardano.Address.CredentialHash"},{"name":"extractCredentialKeyHash","comment":" Extract the credential key hash (Nothing if it’s a script).\n","type":"Cardano.Address.Credential -> Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Address.CredentialHash)"},{"name":"extractNetworkId","comment":" Extract the network ID from an address. Return [Nothing] for a Byron address.\n","type":"Cardano.Address.Address -> Maybe.Maybe Cardano.Address.NetworkId"},{"name":"extractPubKeyHash","comment":" Extract the pubkey hash of a Shelley wallet address.\n","type":"Cardano.Address.Address -> Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Address.CredentialHash)"},{"name":"extractStakeCredential","comment":" Extract the stake credential part of a Shelley address.\n","type":"Cardano.Address.Address -> Maybe.Maybe Cardano.Address.StakeCredential"},{"name":"extractStakeKeyHash","comment":" Extract the stake key hash of a Shelley address.\n","type":"Cardano.Address.Address -> Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Address.CredentialHash)"},{"name":"fromBech32","comment":" Build an [Address] from its Bech32 string representation (CIP 5).\n","type":"String.String -> Maybe.Maybe Cardano.Address.Address"},{"name":"fromBytes","comment":" Convert an [Address] from its [Bytes] representation.\n","type":"Bytes.Comparable.Bytes a -> Maybe.Maybe Cardano.Address.Address"},{"name":"fromString","comment":" Build an [Address] from any valid string representation, such as Hex or Bech32.\n","type":"String.String -> Maybe.Maybe Cardano.Address.Address"},{"name":"isShelleyWallet","comment":" Check if an [Address] is of the Shelley type, with a wallet payment key, not a script.\n","type":"Cardano.Address.Address -> Basics.Bool"},{"name":"networkIdFromInt","comment":" Convert to [NetworkId] from its integer representation.\n","type":"Basics.Int -> Maybe.Maybe Cardano.Address.NetworkId"},{"name":"pointer","comment":" Create a pointer address.\n","type":"Cardano.Address.NetworkId -> Cardano.Address.Credential -> { slotNumber : Basics.Int, transactionIndex : Basics.Int, certificateIndex : Basics.Int } -> Cardano.Address.Address"},{"name":"script","comment":" Create a simple script address, with only a payment credential and no stake credential.\n","type":"Cardano.Address.NetworkId -> Bytes.Comparable.Bytes Cardano.Address.CredentialHash -> Cardano.Address.Address"},{"name":"setShelleyStakeCred","comment":" Change the stake credential part of a Shelley address.\nIgnored if the address is anything else (Byron/Reward).\n","type":"Maybe.Maybe Cardano.Address.StakeCredential -> Cardano.Address.Address -> Cardano.Address.Address"},{"name":"stakeAddressToBytes","comment":" Convert a stake address to its bytes representation.\n","type":"Cardano.Address.StakeAddress -> Bytes.Comparable.Bytes Cardano.Address.StakeAddress"},{"name":"stakeAddressToCbor","comment":" CBOR encoder for a stake address.\n","type":"Cardano.Address.StakeAddress -> Cbor.Encode.Encoder"},{"name":"stakeDictFromList","comment":" Create a stake address dictionary from a list.\nFor other operations, use the `AnyDict` module directly.\n\nThe keys order are derived from Haskell auto-derived credential order.\nMeaning Script first, then VKey.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"List.List ( Cardano.Address.StakeAddress, a ) -> Cardano.Address.StakeDict a"},{"name":"toBech32","comment":" Convert an [Address] into its Bech32 string representation (CIP 5).\n","type":"Cardano.Address.Address -> String.String"},{"name":"toBytes","comment":" Convert an [Address] to its underlying [Bytes] representation.\n\nByron addresses are left untouched as we don't plan to have full support of Byron era.\n\nShelley address description from CIP-0019:\n\n    Header type (tttt....)  Payment Part     Delegation Part\n    (0) 0000....            PaymentKeyHash   StakeKeyHash\n    (1) 0001....            ScriptHash       StakeKeyHash\n    (2) 0010....            PaymentKeyHash   ScriptHash\n    (3) 0011....            ScriptHash       ScriptHash\n    (4) 0100....            PaymentKeyHash   Pointer\n    (5) 0101....            ScriptHash       Pointer\n    (6) 0110....            PaymentKeyHash   ø\n    (7) 0111....            ScriptHash       ø\n\n    Header type (....tttt)\n    (0) ....0000 testnet\n    (1) ....0001 mainnet\n\nFor example, `61....(56 chars / 28 bytes)....` is an enterprise address (6, only a payment key) on mainnet (1).\n\nStake address description from CIP-0019:\n\n    Header type (tttt....)  Stake Reference\n    (14) 1110....           StakeKeyHash\n    (15) 1111....           ScriptHash\n\n","type":"Cardano.Address.Address -> Bytes.Comparable.Bytes Cardano.Address.Address"},{"name":"toCbor","comment":" Encode an [Address] to CBOR.\n","type":"Cardano.Address.Address -> Cbor.Encode.Encoder"}],"binops":[]},{"name":"Cardano.AuxiliaryData","comment":"\n\n@docs AuxiliaryData, fromJustLabels\n\n@docs hash, Hash\n\n@docs fromCbor, toCbor\n\n","unions":[{"name":"Hash","comment":" Phantom type for auxiliary data hashes.\nThis is a 32-bytes Blake2b-256 hash.\n","args":[],"cases":[]}],"aliases":[{"name":"AuxiliaryData","comment":" [Transaction] auxiliary data.\n","args":[],"type":"{ labels : List.List ( Natural.Natural, Cardano.Metadatum.Metadatum ), nativeScripts : List.List Cardano.Script.NativeScript, plutusV1Scripts : List.List (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor), plutusV2Scripts : List.List (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor), plutusV3Scripts : List.List (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor) }"}],"values":[{"name":"fromCbor","comment":" Decode transaction auxiliary data from CBOR.\n","type":"Cbor.Decode.Decoder Cardano.AuxiliaryData.AuxiliaryData"},{"name":"fromJustLabels","comment":" Create [AuxiliaryData] with just labels, no scripts.\n","type":"List.List ( Natural.Natural, Cardano.Metadatum.Metadatum ) -> Cardano.AuxiliaryData.AuxiliaryData"},{"name":"hash","comment":" Compute auxiliary data hash.\n","type":"Cardano.AuxiliaryData.AuxiliaryData -> Bytes.Comparable.Bytes Cardano.AuxiliaryData.Hash"},{"name":"toCbor","comment":" Encode transaction auxiliary data to CBOR.\n","type":"Cardano.AuxiliaryData.AuxiliaryData -> Cbor.Encode.Encoder"}],"binops":[]},{"name":"Cardano.Cip30","comment":" CIP 30 support.\n\n@docs WalletDescriptor, Wallet, walletDescriptor, walletChangeAddress, updateChangeAddress\n\n@docs Request, encodeRequest, Paginate\n\n@docs discoverWallets, enableWallet\n\n@docs getExtensions, getNetworkId, getUtxos, getCollateral, getBalance\n\n@docs getUsedAddresses, getUnusedAddresses, getChangeAddress, getRewardAddresses\n\n@docs signTx, signTxCbor, KeyType, signData, submitTx, submitTxCbor\n\n@docs apiRequest\n\n@docs Response, ApiResponse, Utxo, DataSignature, responseDecoder, apiDecoder, utxoDecoder, hexCborDecoder, addressDecoder, dataSignatureDecoder\n\n","unions":[{"name":"ApiResponse","comment":" Response type for all API requests done through the `api` object returned when enabling a wallet.\n","args":[],"cases":[["Extensions",["List.List Basics.Int"]],["NetworkId",["Cardano.Address.NetworkId"]],["WalletUtxos",["List.List Cardano.Cip30.Utxo"]],["Collateral",["List.List Cardano.Cip30.Utxo"]],["WalletBalance",["Cardano.Value.Value"]],["UsedAddresses",["List.List Cardano.Address.Address"]],["UnusedAddresses",["List.List Cardano.Address.Address"]],["ChangeAddress",["Cardano.Address.Address"]],["RewardAddresses",["List.List Cardano.Address.Address"]],["SignedTx",["List.List Cardano.Transaction.VKeyWitness"]],["SignedData",["Cardano.Cip30.DataSignature"]],["SubmittedTx",["Bytes.Comparable.Bytes Cardano.Utxo.TransactionId"]],["UnhandledApiResponse",["String.String"]]]},{"name":"KeyType","comment":" Key type used for data signature.\n","args":[],"cases":[["PaymentKey",[]],["StakeKey",[]]]},{"name":"Request","comment":" Opaque type for requests to be sent to the wallets.\n","args":[],"cases":[]},{"name":"Response","comment":" Response type for responses from the browser wallets.\n","args":["apiResponse"],"cases":[["AvailableWallets",["List.List Cardano.Cip30.WalletDescriptor"]],["EnabledWallet",["Cardano.Cip30.Wallet"]],["ApiResponse",["{ walletId : String.String }","apiResponse"]],["ApiError",["{ walletId : Maybe.Maybe String.String, code : Basics.Int, info : String.String }"]],["UnhandledResponseType",["String.String"]]]},{"name":"Wallet","comment":" Opaque Wallet object to be used for all API requests.\n","args":[],"cases":[]}],"aliases":[{"name":"DataSignature","comment":" Signature returned from the wallet after signing a payload with your stake key.\n","args":[],"type":"{ signature : Cbor.CborItem, key : Cbor.CborItem }"},{"name":"Paginate","comment":" Paginate requests that may return many elements.\n","args":[],"type":"{ page : Basics.Int, limit : Basics.Int }"},{"name":"Utxo","comment":" UTxO type holding the reference and actual output.\n","args":[],"type":"( Cardano.Utxo.OutputReference, Cardano.Utxo.Output )"},{"name":"WalletDescriptor","comment":" The type returned when asking for available wallets.\n","args":[],"type":"{ id : String.String, name : String.String, icon : String.String, apiVersion : String.String, isEnabled : Basics.Bool, supportedExtensions : List.List Basics.Int }"}],"values":[{"name":"addressDecoder","comment":" JSON decoder for an [Address] encoded as hexadecimal string.\n","type":"Json.Decode.Decoder Cardano.Address.Address"},{"name":"apiDecoder","comment":" API response decoder for CIP-30.\nIntented to be provided as argument to the `responseDecoder` function.\n","type":"String.String -> Json.Decode.Decoder Cardano.Cip30.ApiResponse"},{"name":"apiRequest","comment":" Make a CIP-30 API request.\n\nThis is mainly a helper function, exposed for implementors of extensions, like CIP-95.\n\n","type":"Cardano.Cip30.Wallet -> Maybe.Maybe Basics.Int -> String.String -> List.List Json.Decode.Value -> Cardano.Cip30.Request"},{"name":"dataSignatureDecoder","comment":" Helper function to decode data signatures.\n","type":"Json.Decode.Decoder Cardano.Cip30.DataSignature"},{"name":"discoverWallets","comment":" Typically the first request you have to send, to discover which wallets are installed.\n\nWill typically be followed by a response of the [AvailableWallets] variant\ncontaining a [WalletDescriptor] for each discovered wallet.\n\n","type":"Cardano.Cip30.Request"},{"name":"enableWallet","comment":" Enable an installed wallet.\n\nWill typically be followed by a response of the [EnabledWallet] variant\ncontaining a [Wallet] to be stored in your model.\n\nOptionally, you can watch for changes of the selected wallet at a regular interval (in seconds).\nEach time, the wallet will check the current change address and notify with a `ChangeAddress` API response if it has changed.\n\n","type":"{ id : String.String, extensions : List.List Basics.Int, watchInterval : Maybe.Maybe Basics.Int } -> Cardano.Cip30.Request"},{"name":"encodeRequest","comment":" Encode a [Request] into a JS value that can be sent through a port.\n","type":"Cardano.Cip30.Request -> Json.Decode.Value"},{"name":"getBalance","comment":" Get the current wallet balance.\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.Request"},{"name":"getChangeAddress","comment":" Get an address that can be used to send funds to this wallet.\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.Request"},{"name":"getCollateral","comment":" Get a list of UTxOs to be used for collateral.\n\nYou need to specify the amount of lovelace you need for collateral.\nMore info about why that is in the [CIP 30 spec][cip-collateral].\n\n[cip-collateral]: https://cips.cardano.org/cips/cip30/#apigetcollateralparamsamountcborcoinpromisetransactionunspentoutputnull\n\n","type":"Cardano.Cip30.Wallet -> { amount : Natural.Natural } -> Cardano.Cip30.Request"},{"name":"getExtensions","comment":" Get the list of extensions enabled by the wallet.\n\nThis feature isn't well supported yet by wallets (as of 2023-10).\n\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.Request"},{"name":"getNetworkId","comment":" Get the current network ID of the wallet.\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.Request"},{"name":"getRewardAddresses","comment":" Get addresses used to withdraw staking rewards.\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.Request"},{"name":"getUnusedAddresses","comment":" Get a list of unused addresses.\n\nAvoid this feature if possible.\nIt is not consistent and not compatible with single-address wallets.\n\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.Request"},{"name":"getUsedAddresses","comment":" Get a list of used addresses from the wallet.\n\nThat list is wallet-dependent and may not contain all used addresses.\nDo not rely on this as a source of truth to get all addresses of a user.\n\n","type":"Cardano.Cip30.Wallet -> { paginate : Maybe.Maybe Cardano.Cip30.Paginate } -> Cardano.Cip30.Request"},{"name":"getUtxos","comment":" Get a list of UTxOs in the wallet.\n","type":"Cardano.Cip30.Wallet -> { amount : Maybe.Maybe Cardano.Value.Value, paginate : Maybe.Maybe Cardano.Cip30.Paginate } -> Cardano.Cip30.Request"},{"name":"hexCborDecoder","comment":" Helper function to decode CBOR as hex in JSON.\n","type":"Cbor.Decode.Decoder a -> Json.Decode.Decoder a"},{"name":"responseDecoder","comment":" Decoder for the [Response] type.\n","type":"Dict.Dict Basics.Int (String.String -> Json.Decode.Decoder apiResponse) -> Json.Decode.Decoder (Cardano.Cip30.Response apiResponse)"},{"name":"signData","comment":" Sign an arbitrary payload with your wallet keys.\nYou can provide one of your payment or stake credential handled by the wallet.\n","type":"Cardano.Cip30.Wallet -> { networkId : Cardano.Address.NetworkId, keyType : Cardano.Cip30.KeyType, keyHash : Bytes.Comparable.Bytes Cardano.Address.CredentialHash, payload : Bytes.Comparable.Bytes a } -> Cardano.Cip30.Request"},{"name":"signTx","comment":" Sign a transaction.\n","type":"Cardano.Cip30.Wallet -> { partialSign : Basics.Bool } -> Cardano.Transaction.Transaction -> Cardano.Cip30.Request"},{"name":"signTxCbor","comment":" Sign a transaction, already CBOR-encoded (to avoid deserialization-serialization mismatch).\n","type":"Cardano.Cip30.Wallet -> { partialSign : Basics.Bool } -> Bytes.Comparable.Bytes Cardano.Transaction.Transaction -> Cardano.Cip30.Request"},{"name":"submitTx","comment":" Encode a transaction and submit it via the wallet.\n","type":"Cardano.Cip30.Wallet -> Cardano.Transaction.Transaction -> Cardano.Cip30.Request"},{"name":"submitTxCbor","comment":" Submit a transaction, already CBOR-encoded (to avoid deserialization-serialization mismatch).\n","type":"Cardano.Cip30.Wallet -> Bytes.Comparable.Bytes Cardano.Transaction.Transaction -> Cardano.Cip30.Request"},{"name":"updateChangeAddress","comment":" Update the change address associated with a [Wallet] object.\n","type":"Cardano.Address.Address -> Cardano.Cip30.Wallet -> Cardano.Cip30.Wallet"},{"name":"utxoDecoder","comment":" Decode UTxO pairs encoded as CBOR in a hex JSON field.\n","type":"Json.Decode.Decoder Cardano.Cip30.Utxo"},{"name":"walletChangeAddress","comment":" Retrieve the change address associated with a [Wallet] object.\n","type":"Cardano.Cip30.Wallet -> Cardano.Address.Address"},{"name":"walletDescriptor","comment":" Retrieve the descriptor associated with a [Wallet] object.\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.WalletDescriptor"}],"binops":[]},{"name":"Cardano.Cip67","comment":" CIP-0067 support.\n\nCIP-0067 [describes](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0067)\na standard format for assets so that their purpose can be deduced solely by\ntheir token names. So far, the primary application of this standard is to\neasily distinguish between CIP-0068 assets and their reference counterparts.\n\n@docs Cip67, AssetName\n\n@docs fromBytes, labelFromHex, fromCbor\n\n@docs toBytes, labelToHex, toCbor\n\n","unions":[{"name":"AssetName","comment":" Phantom type for CIP-0067 asset names with the label prefix removed.\n","args":[],"cases":[]}],"aliases":[{"name":"Cip67","comment":" Datatype for modeling CIP-0067.\n\nThis standard offers a label number preceding the actual token name, which can\nbe from `0` to `65535` (i.e. 2 bytes, and left-padded with `00` for numbers\nsmaller than 2 bytes). This label should be formatted as such:\n\n    --  openning bracket                             closing bracket\n    --       ┌──┐                                         ┌──┐\n    --     [ 0000 | 16 bits label_num | 8 bits checksum | 0000 ]\n    --              └───────────────┘   └───────┬─────┘\n    --        fixed 2 bytes for the label       │\n    --                                          │\n    -- label's checksum found by applying the CRC-8 algorithm to its 2 bytes\n\n\n\nThe [polynomial representation](https://wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Polynomial_representations)\nof the CRC-8 is `0x07` (`0b00000111`).\n\nAs an example, a label of `222` turn into: `0x000de140`\n\n1.  Hex equivalent of decimal `222` is `0xde`\n2.  Since it's less than 2 bytes, we add `0x00` to the left and get `0x00de`\n3.  Find its CRC-8 checksum (`0x14`)\n4.  Concatenate the two and wrap in \"brackets\" to get the final bytes: `0x000de140`\n\nFinally, a complete CIP-0067 example:\n\n\n    spacebudz2921 : Maybe Cip67\n    spacebudz2921 =\n        Maybe.andThen Cip67.fromBytes <| Bytes.fromHex \"000de14042756432393231\"\n\n    -- Just { assetName = Bytes \"42756432393231\", label = 222 }\n\n","args":[],"type":"{ label : Basics.Int, assetName : Bytes.Comparable.Bytes Cardano.Cip67.AssetName }"}],"values":[{"name":"fromBytes","comment":" Validate and separate the label of a CIP-0067 asset name.\n\nGiven a valid CIP-0067 token name [Bytes], this function separates the label as\nan [Int], and returns the asset name without the label bytes.\n\n","type":"Bytes.Comparable.Bytes Cardano.MultiAsset.AssetName -> Maybe.Maybe Cardano.Cip67.Cip67"},{"name":"fromCbor","comment":" CBOR decoder for [Cip67].\n","type":"Cbor.Decode.Decoder Cardano.Cip67.Cip67"},{"name":"labelFromHex","comment":" Extract the label if it is valid. Return Nothing otherwise.\n","type":"String.String -> Maybe.Maybe Basics.Int"},{"name":"labelToHex","comment":" Convert an Int label into its CIP-0067 hex string.\n","type":"Basics.Int -> String.String"},{"name":"toBytes","comment":" Converts a [Cip67] to [Bytes].\n","type":"Cardano.Cip67.Cip67 -> Bytes.Comparable.Bytes Cardano.MultiAsset.AssetName"},{"name":"toCbor","comment":" CBOR encoder.\n","type":"Cardano.Cip67.Cip67 -> Cbor.Encode.Encoder"}],"binops":[]},{"name":"Cardano.Cip95","comment":" CIP 95 support.\n\n@docs getPubDRepKey, getRegisteredPubStakeKeys, getUnregisteredPubStakeKeys, signData\n\n@docs ApiResponse, apiDecoder\n\n","unions":[{"name":"ApiResponse","comment":" Response type for all API requests done through the `api` object returned when enabling a wallet.\n","args":[],"cases":[["DrepKey",["Bytes.Comparable.Bytes Cardano.Transaction.Ed25519PublicKey"]],["RegisteredStakeKeys",["List.List (Bytes.Comparable.Bytes Cardano.Transaction.Ed25519PublicKey)"]],["UnregisteredStakeKeys",["List.List (Bytes.Comparable.Bytes Cardano.Transaction.Ed25519PublicKey)"]],["SignedData",["Cardano.Cip30.DataSignature"]],["UnhandledApiResponse",["String.String"]]]}],"aliases":[],"values":[{"name":"apiDecoder","comment":" API response decoder for CIP-30.\nIntented to be provided as argument to the `responseDecoder` function.\n","type":"String.String -> Json.Decode.Decoder Cardano.Cip95.ApiResponse"},{"name":"getPubDRepKey","comment":" Retrieve the wallet account public DRep key, derived as described in CIP-105.\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.Request"},{"name":"getRegisteredPubStakeKeys","comment":" Retrieve the wallet account registered public stake keys.\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.Request"},{"name":"getUnregisteredPubStakeKeys","comment":" Retrieve the wallet account unregistered public stake keys.\n","type":"Cardano.Cip30.Wallet -> Cardano.Cip30.Request"},{"name":"signData","comment":" Sign a payload with a given key, using CIP-8 signature scheme.\nThe credential should correspond to the DRep ID expected to sign.\n","type":"Cardano.Cip30.Wallet -> { drepId : Bytes.Comparable.Bytes Cardano.Address.CredentialHash, payload : Bytes.Comparable.Bytes a } -> Cardano.Cip30.Request"}],"binops":[]},{"name":"Cardano.CoinSelection","comment":" Module `Cardano.CoinSelection` provides functionality for performing\ncoin selection based on a set of available UTXOs and a set of requested outputs.\nIt exports functions for sorting UTXOs and performing the Largest-First coin\nselection algorithm as described in CIP2 (<https://cips.cardano.org/cips/cip2/>).\n\n\n# Types\n\n@docs Context, Error, errorToString, Selection, Algorithm\n\n\n# Strategies\n\n@docs largestFirst, inOrderedList\n\n\n# Per-address Selection\n\n@docs perAddress, PerAddressConfig, PerAddressContext\n\n\n# Collateral Selection\n\n@docs CollateralContext, collateral\n\n","unions":[{"name":"Error","comment":" Enumerates the possible errors that can occur during coin selection.\n","args":[],"cases":[["MaximumInputCountExceeded",[]],["UTxOBalanceInsufficient",["{ selectedUtxos : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), missingValue : Cardano.Value.Value }"]]]}],"aliases":[{"name":"Algorithm","comment":" Alias for the function signature of a utxo selection algorithm.\n","args":[],"type":"Basics.Int -> Cardano.CoinSelection.Context -> Result.Result Cardano.CoinSelection.Error Cardano.CoinSelection.Selection"},{"name":"CollateralContext","comment":" Holds the arguments necessary for performing collateral selection.\n","args":[],"type":"{ availableUtxos : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), allowedAddresses : Cardano.Address.Dict (), targetAmount : Natural.Natural }"},{"name":"Context","comment":" Holds the arguments necessary for performing coin selection.\n","args":[],"type":"{ availableUtxos : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), alreadySelectedUtxos : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), targetAmount : Cardano.Value.Value }"},{"name":"PerAddressConfig","comment":" Configuration of the per-address section algorithm.\n\nSince the per-address algorithm also merges the change with pre-existing owed values,\nyou need to provide two additional algorithms:\n\n  - normalizationAlgo: specifies how to simplify the target input and pre-owed value\n  - changeAlgo: specifies how to split (or not) the returned change into multiple outputs\n\nThe normalization algorithm enables control over what to do in situations where\nthe same address is both asked some value and returned some value.\nLet’s take the simplified example where intents are spending 10 ada,\nand returning 15 ada to the same address.\nIf we normalize the asked and owed value, the result is just to return 5 ada,\nso we don’t even need to perform coin selection for this address, since the balance is strictly positive.\n\nBut sometimes you might want to force UTxO selection, even if the balance is null.\nFor example if you want to collect all native tokens of a given policyId into a single output.\n\nSo by making both the normalization algorithm and the change algorithm configurable,\nwe enable easily customizable behaviors, per-address.\nBecause you might not want the same strategy for the wallet address and for other addresses.\n\n","args":[],"type":"{ selectionAlgo : Cardano.CoinSelection.Algorithm, normalizationAlgo : { target : Cardano.Value.Value, owed : Cardano.Value.Value } -> { normalizedTarget : Cardano.Value.Value, normalizedOwed : Cardano.Value.Value }, changeAlgo : Cardano.Value.Value -> List.List Cardano.Value.Value }"},{"name":"PerAddressContext","comment":" The per-address coin selection context.\n\nIn addition to all three fields of the usual selection `Context`,\nthis one also contains an `alreadyOwed` value.\n\nThe reason is that per-address coin selection is intended to be run by\nthe Tx building algorithm, and expects to generate actual `Output` returned values.\nThese outputs will merge both the coin selection change,\nand value that was already destined to a given address.\nKnowledge of both enables better handling of change outputs and minAda for these.\n\n","args":[],"type":"{ availableUtxos : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), alreadySelectedUtxos : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), targetValue : Cardano.Value.Value, alreadyOwed : Cardano.Value.Value }"},{"name":"Selection","comment":" Represents the result of a successful coin selection.\n","args":[],"type":"{ selectedUtxos : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), change : Maybe.Maybe Cardano.Value.Value }"}],"values":[{"name":"collateral","comment":" Perform collateral selection.\n\nOnly UTxOs at the provided whitelist of addresses are viable.\nUTxOs are picked following a prioritization list.\n\n  - First, prioritize UTxOs with only Ada in them,\n    and with >= ? Ada, but lowest amounts prioritized over higher amounts.\n  - Second, prioritize UTxOs with >= ? Ada, and that would cost minimal fees to add,\n    so basically no reference script, no datums, and minimal number of assets.\n  - Third, everything else, prioritized with >= ? Ada first,\n    and sorted by minimal fee cost associated.\n  - Finally, all the rest, sorted by \"available\" ada amounts (without min Ada),\n    with bigger available amounts prioritized over smaller amounts.\n\n","type":"Cardano.CoinSelection.CollateralContext -> Result.Result Cardano.CoinSelection.Error Cardano.CoinSelection.Selection"},{"name":"errorToString","comment":" Converts an error to a human-readable string.\n","type":"Cardano.CoinSelection.Error -> String.String"},{"name":"inOrderedList","comment":" Implements the simplest coin selection algorithm,\nwhich just adds UTxOs until the target amount is reached.\n\nTakes a `Context` record containing the available UTXOs, initially\nselected UTXOs, requested outputs, and change address, along with an `Int`\nrepresenting the maximum number of inputs allowed. Returns either a\n`Error` or a `Selection`.\n\nRemark: the selected UTxOs are returned in reverse order for efficiency of list construction.\n\nTODO: if possible, remove extraneous inputs.\nIndeed, when selecting later CNT, they might contain enough previous CNT too.\n\n","type":"Basics.Int -> Cardano.CoinSelection.Context -> Result.Result Cardano.CoinSelection.Error Cardano.CoinSelection.Selection"},{"name":"largestFirst","comment":" Implements the Largest-First coin selection algorithm as described in CIP2.\n\nTakes a `Context` record containing the available UTXOs, initially\nselected UTXOs, requested outputs, and change address, along with an `Int`\nrepresenting the maximum number of inputs allowed. Returns either a\n`Error` or a `Selection`. See <https://cips.cardano.org/cips/cip2/#largestfirst>\n\nTODO: if possible, remove extraneous inputs.\nIndeed, when selecting later CNT, they might contain enough previous CNT too.\n\n","type":"Basics.Int -> Cardano.CoinSelection.Context -> Result.Result Cardano.CoinSelection.Error Cardano.CoinSelection.Selection"},{"name":"perAddress","comment":" Per-address coin selection algorithm.\n\nThis is intended to be used by the Tx building algorithm, but also available publicly.\nContrary to the generic coin selection algorithm that has no notion of addresses,\nthis algorithm performs coin selection per-address.\nIt also provides a more fine-grained handling of the selection change outputs.\n\nBy making it per-address configurable, we enable easy customization\nof the selection algorithm, and the change algorithm depending\non the type of address being handled.\nFor example, the connected wallet address can pre-split the change,\nto keep around UTxOs for collaterals,\nwhile any other address could bundle everything into a single UTxO.\n\n","type":"(Cardano.Address.Address -> Cardano.CoinSelection.PerAddressConfig) -> Cardano.Address.Dict Cardano.CoinSelection.PerAddressContext -> Result.Result Cardano.CoinSelection.Error (Cardano.Address.Dict { selectedUtxos : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), changeOutputs : List.List Cardano.Utxo.Output })"}],"binops":[]},{"name":"Cardano.Data","comment":" Handling Cardano Data objects.\n\n@docs Data, hash, rawDatumHash, fromBytes, fromCbor, toCbor, toCborUplc\n\n","unions":[{"name":"Data","comment":" A Data is a compound type that can represent any possible user-defined type in Aiken.\n","args":[],"cases":[["Constr",["Natural.Natural","List.List Cardano.Data.Data"]],["Map",["List.List ( Cardano.Data.Data, Cardano.Data.Data )"]],["List",["List.List Cardano.Data.Data"]],["Int",["Integer.Integer"]],["Bytes",["Bytes.Comparable.Bytes Bytes.Comparable.Any"]]]}],"aliases":[],"values":[{"name":"fromBytes","comment":" Helper function to decode a Data object from its raw CBOR bytes.\n","type":"Bytes.Comparable.Bytes a -> Maybe.Maybe Cardano.Data.Data"},{"name":"fromCbor","comment":" CBOR decoder for [Data].\n","type":"Cbor.Decode.Decoder Cardano.Data.Data"},{"name":"hash","comment":" Compute the Blake2b-256 (32 bytes) hash of a Data object.\n","type":"Cardano.Data.Data -> Bytes.Comparable.Bytes a"},{"name":"rawDatumHash","comment":" Helper function to compute the Blake2b-256 hash of the raw Data bytes in a UTxO datum.\n","type":"Bytes.Comparable.Bytes Cardano.Data.Data -> Bytes.Comparable.Bytes a"},{"name":"toCbor","comment":" CBOR encoder for [Data].\n","type":"Cardano.Data.Data -> Cbor.Encode.Encoder"},{"name":"toCborUplc","comment":" CBOR encoder for [Data].\nOnly to be used for things sent to the UPLC VM,\nsuch as datums, redeemers, and script parameter application.\n","type":"Cardano.Data.Data -> Cbor.Encode.Encoder"}],"binops":[]},{"name":"Cardano.Gov","comment":" Handling gov-related stuff.\n\n@docs Id, idFromBech32, idToBech32\n\n@docs Drep, decodeDrep, encodeDrep\n\n@docs ProposalProcedure, proposalProcedureFromCbor\n\n@docs Action, decodeAction, encodeAction\n\n@docs ActionId, actionIdToString, actionIdFromCbor, encodeActionId\n\n@docs Constitution, decodeConstitution, encodeConstitution\n\n@docs ProtocolParamUpdate, noParamUpdate, decodeProtocolParamUpdate, encodeProtocolParamUpdate\n\n@docs PoolVotingThresholds, decodePoolVotingThresholds, encodePoolVotingThresholds\n\n@docs DrepVotingThresholds, decodeDrepVotingThresholds, encodeDrepVotingThresholds\n\n@docs CostModels, decodeCostModels, encodeCostModels\n\n@docs ProtocolVersion, decodeProtocolVersion, encodeProtocolVersion\n\n@docs Nonce\n\n@docs VotingProcedure, votingProcedureFromCbor, encodeVotingProcedure\n\n@docs Vote, encodeVote\n\n@docs Voter, VoterDict, emptyVoterDict, voterDictFromList, voterToId, voterCredentialHash, voterKeyCred, voterLedgerOrder, voterFromCbor, encodeVoter\n\n@docs Anchor, AnchorDataHash, decodeAnchor, encodeAnchor\n\n","unions":[{"name":"Action","comment":" Represents different types of governance actions.\n","args":[],"cases":[["ParameterChange",["{ latestEnacted : Maybe.Maybe Cardano.Gov.ActionId, protocolParamUpdate : Cardano.Gov.ProtocolParamUpdate, guardrailsPolicy : Maybe.Maybe (Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId) }"]],["HardForkInitiation",["{ latestEnacted : Maybe.Maybe Cardano.Gov.ActionId, protocolVersion : Cardano.Gov.ProtocolVersion }"]],["TreasuryWithdrawals",["{ withdrawals : List.List ( Cardano.Address.StakeAddress, Natural.Natural ), guardrailsPolicy : Maybe.Maybe (Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId) }"]],["NoConfidence",["{ latestEnacted : Maybe.Maybe Cardano.Gov.ActionId }"]],["UpdateCommittee",["{ latestEnacted : Maybe.Maybe Cardano.Gov.ActionId, removedMembers : List.List Cardano.Address.Credential, addedMembers : List.List { newMember : Cardano.Address.Credential, expirationEpoch : Natural.Natural }, quorumThreshold : Cardano.Utils.UnitInterval }"]],["NewConstitution",["{ latestEnacted : Maybe.Maybe Cardano.Gov.ActionId, constitution : Cardano.Gov.Constitution }"]],["Info",[]]]},{"name":"AnchorDataHash","comment":" Opaque phantom type for an [Anchor] data hash.\nIt is 32-bytes long.\n","args":[],"cases":[]},{"name":"Drep","comment":" Delegate representative.\n","args":[],"cases":[["DrepCredential",["Cardano.Address.Credential"]],["AlwaysAbstain",[]],["AlwaysNoConfidence",[]]]},{"name":"Id","comment":" Governance Id related to [CIP 129](https://github.com/cardano-foundation/CIPs/blob/master/CIP-0129/README.md).\nIn addition to CC and DRep, this also includes SPOs as potential governance Ids!\n","args":[],"cases":[["CcHotCredId",["Cardano.Address.Credential"]],["CcColdCredId",["Cardano.Address.Credential"]],["DrepId",["Cardano.Address.Credential"]],["PoolId",["Bytes.Comparable.Bytes Cardano.Pool.Id"]],["GovActionId",["Cardano.Gov.ActionId"]]]},{"name":"Nonce","comment":" Represents a nonce for extra entropy.\n","args":[],"cases":[["Just0",[]],["RandomBytes",["Bytes.Comparable.Bytes Bytes.Comparable.Any"]]]},{"name":"Vote","comment":" Represents different types of votes.\n","args":[],"cases":[["VoteNo",[]],["VoteYes",[]],["VoteAbstain",[]]]},{"name":"Voter","comment":" Represents different types of voters.\n","args":[],"cases":[["VoterCommitteeHotCred",["Cardano.Address.Credential"]],["VoterDrepCred",["Cardano.Address.Credential"]],["VoterPoolId",["Bytes.Comparable.Bytes Cardano.Address.CredentialHash"]]]}],"aliases":[{"name":"ActionId","comment":" Represents an action ID.\n","args":[],"type":"{ transactionId : Bytes.Comparable.Bytes Cardano.Utxo.TransactionId, govActionIndex : Basics.Int }"},{"name":"Anchor","comment":" Represents an anchor for governance actions.\n","args":[],"type":"{ url : String.String, dataHash : Bytes.Comparable.Bytes Cardano.Gov.AnchorDataHash }"},{"name":"Constitution","comment":" Represents a constitution.\n","args":[],"type":"{ anchor : Cardano.Gov.Anchor, scripthash : Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Address.CredentialHash) }"},{"name":"CostModels","comment":" Represents cost models for different Plutus versions.\n","args":[],"type":"{ plutusV1 : Maybe.Maybe (List.List Basics.Int), plutusV2 : Maybe.Maybe (List.List Basics.Int), plutusV3 : Maybe.Maybe (List.List Basics.Int) }"},{"name":"DrepVotingThresholds","comment":" Represents voting thresholds for delegate representatives.\n","args":[],"type":"{ motionNoConfidence : Cardano.Utils.UnitInterval, committeeNormal : Cardano.Utils.UnitInterval, committeeNoConfidence : Cardano.Utils.UnitInterval, updateConstitution : Cardano.Utils.UnitInterval, hardforkInitiation : Cardano.Utils.UnitInterval, ppNetworkGroup : Cardano.Utils.UnitInterval, ppEconomicGroup : Cardano.Utils.UnitInterval, ppTechnicalGroup : Cardano.Utils.UnitInterval, ppGovernanceGroup : Cardano.Utils.UnitInterval, treasuryWithdrawal : Cardano.Utils.UnitInterval }"},{"name":"PoolVotingThresholds","comment":" Represents voting thresholds for stake pools.\n","args":[],"type":"{ motionNoConfidence : Cardano.Utils.UnitInterval, committeeNormal : Cardano.Utils.UnitInterval, committeeNoConfidence : Cardano.Utils.UnitInterval, hardforkInitiation : Cardano.Utils.UnitInterval, securityRelevantParameter : Cardano.Utils.UnitInterval }"},{"name":"ProposalProcedure","comment":" Represents a proposal procedure.\n","args":[],"type":"{ deposit : Natural.Natural, depositReturnAccount : Cardano.Address.StakeAddress, govAction : Cardano.Gov.Action, anchor : Cardano.Gov.Anchor }"},{"name":"ProtocolParamUpdate","comment":" Adjustable parameters that power key aspects of the network.\n","args":[],"type":"{ minFeeA : Maybe.Maybe Natural.Natural, minFeeB : Maybe.Maybe Natural.Natural, maxBlockBodySize : Maybe.Maybe Basics.Int, maxTransactionSize : Maybe.Maybe Basics.Int, maxBlockHeaderSize : Maybe.Maybe Basics.Int, keyDeposit : Maybe.Maybe Natural.Natural, poolDeposit : Maybe.Maybe Natural.Natural, maximumEpoch : Maybe.Maybe Natural.Natural, desiredNumberOfStakePools : Maybe.Maybe Basics.Int, poolPledgeInfluence : Maybe.Maybe Cardano.Utils.RationalNumber, expansionRate : Maybe.Maybe Cardano.Utils.UnitInterval, treasuryGrowthRate : Maybe.Maybe Cardano.Utils.UnitInterval, decentralizationConstant : Maybe.Maybe Cardano.Utils.UnitInterval, extraEntropy : Maybe.Maybe Cardano.Gov.Nonce, protocolVersion : Maybe.Maybe Cardano.Gov.ProtocolVersion, minUtxoValue : Maybe.Maybe Natural.Natural, minPoolCost : Maybe.Maybe Natural.Natural, adaPerUtxoByte : Maybe.Maybe Natural.Natural, costModelsForScriptLanguages : Maybe.Maybe Cardano.Gov.CostModels, executionCosts : Maybe.Maybe Cardano.Redeemer.ExUnitPrices, maxTxExUnits : Maybe.Maybe Cardano.Redeemer.ExUnits, maxBlockExUnits : Maybe.Maybe Cardano.Redeemer.ExUnits, maxValueSize : Maybe.Maybe Basics.Int, collateralPercentage : Maybe.Maybe Basics.Int, maxCollateralInputs : Maybe.Maybe Basics.Int, poolVotingThresholds : Maybe.Maybe Cardano.Gov.PoolVotingThresholds, drepVotingThresholds : Maybe.Maybe Cardano.Gov.DrepVotingThresholds, minCommitteeSize : Maybe.Maybe Basics.Int, committeeTermLimit : Maybe.Maybe Natural.Natural, governanceActionValidityPeriod : Maybe.Maybe Natural.Natural, governanceActionDeposit : Maybe.Maybe Natural.Natural, drepDeposit : Maybe.Maybe Natural.Natural, drepInactivityPeriod : Maybe.Maybe Natural.Natural, minFeeRefScriptCostPerByte : Maybe.Maybe Basics.Int }"},{"name":"ProtocolVersion","comment":" Represents a protocol version.\n","args":[],"type":"( Basics.Int, Basics.Int )"},{"name":"VoterDict","comment":" Convenient alias for a `Dict` with [Voter] keys.\nWhen converting to a `List`, its keys are sorted with the same order as the Haskell node.\nThe order is determined by [voterLedgerOrder].\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","args":["a"],"type":"Dict.Any.AnyDict ( Basics.Int, String.String ) Cardano.Gov.Voter a"},{"name":"VotingProcedure","comment":" Represents a voting procedure.\n","args":[],"type":"{ vote : Cardano.Gov.Vote, anchor : Maybe.Maybe Cardano.Gov.Anchor }"}],"values":[{"name":"actionIdFromCbor","comment":" Decoder for ActionId type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.ActionId"},{"name":"actionIdToString","comment":" Convert [ActionId] into its Hex string.\n","type":"Cardano.Gov.ActionId -> String.String"},{"name":"decodeAction","comment":" Decoder for Action type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.Action"},{"name":"decodeAnchor","comment":" Decoder for Anchor type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.Anchor"},{"name":"decodeConstitution","comment":" Decoder for Constitution type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.Constitution"},{"name":"decodeCostModels","comment":" Decoder for CostModels type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.CostModels"},{"name":"decodeDrep","comment":" Decoder for Drep type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.Drep"},{"name":"decodeDrepVotingThresholds","comment":" Decoder for DrepVotingThresholds type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.DrepVotingThresholds"},{"name":"decodePoolVotingThresholds","comment":" Decoder for PoolVotingThresholds type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.PoolVotingThresholds"},{"name":"decodeProtocolParamUpdate","comment":" Decoder for ProtocolParamUpdate type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.ProtocolParamUpdate"},{"name":"decodeProtocolVersion","comment":" Decoder for ProtocolVersion type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.ProtocolVersion"},{"name":"emptyVoterDict","comment":" Create a empty voter dictionary.\nFor other operations, use the `AnyDict` module directly.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"Cardano.Gov.VoterDict a"},{"name":"encodeAction","comment":" Encoder for Action type.\n","type":"Cardano.Gov.Action -> Cbor.Encode.Encoder"},{"name":"encodeActionId","comment":" Encoder for ActionId type.\n","type":"Cardano.Gov.ActionId -> Cbor.Encode.Encoder"},{"name":"encodeAnchor","comment":" Encoder for Anchor type.\n","type":"Cardano.Gov.Anchor -> Cbor.Encode.Encoder"},{"name":"encodeConstitution","comment":" Encoder for Constitution type.\n","type":"Cardano.Gov.Constitution -> Cbor.Encode.Encoder"},{"name":"encodeCostModels","comment":" Encode [CostModels] to CBOR.\n","type":"Cardano.Gov.CostModels -> Cbor.Encode.Encoder"},{"name":"encodeDrep","comment":" Encoder for Drep type.\n","type":"Cardano.Gov.Drep -> Cbor.Encode.Encoder"},{"name":"encodeDrepVotingThresholds","comment":" Encoder for DrepVotingThresholds type.\n","type":"Cardano.Gov.DrepVotingThresholds -> Cbor.Encode.Encoder"},{"name":"encodePoolVotingThresholds","comment":" Encoder for PoolVotingThresholds type.\n","type":"Cardano.Gov.PoolVotingThresholds -> Cbor.Encode.Encoder"},{"name":"encodeProtocolParamUpdate","comment":" Encoder for ProtocolParamUpdate type.\n","type":"Cardano.Gov.ProtocolParamUpdate -> Cbor.Encode.Encoder"},{"name":"encodeProtocolVersion","comment":" Encoder for ProtocolVersion type.\n","type":"Cardano.Gov.ProtocolVersion -> Cbor.Encode.Encoder"},{"name":"encodeVote","comment":" Encoder for Vote type.\n","type":"Cardano.Gov.Vote -> Cbor.Encode.Encoder"},{"name":"encodeVoter","comment":" Encoder for Voter type.\n","type":"Cardano.Gov.Voter -> Cbor.Encode.Encoder"},{"name":"encodeVotingProcedure","comment":" Encoder for VotingProcedure type.\n","type":"Cardano.Gov.VotingProcedure -> Cbor.Encode.Encoder"},{"name":"idFromBech32","comment":" Convert a Gov Id from its Bech32 governance Id (CIP 129) or Pool Id (CIP 5).\n\nRemark: will fail if a gov action index is >= 256 since we make the simplifying assumption it’s only 1 byte long.\n\n","type":"String.String -> Maybe.Maybe Cardano.Gov.Id"},{"name":"idToBech32","comment":" Convert a Gov Id from its Bech32 governance Id (CIP 129) or Pool Id (CIP 5).\n\nRemark: will be wrong if a gov action index is >= 256 since we make the simplifying assumption it’s only 1 byte long.\n\n","type":"Cardano.Gov.Id -> String.String"},{"name":"noParamUpdate","comment":" Default (no update) for [ProtocolParamUpdate].\n","type":"Cardano.Gov.ProtocolParamUpdate"},{"name":"proposalProcedureFromCbor","comment":" Decoder for ProposalProcedure type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.ProposalProcedure"},{"name":"voterCredentialHash","comment":" Extract the credential hash of a voter.\n","type":"Cardano.Gov.Voter -> Bytes.Comparable.Bytes Cardano.Address.CredentialHash"},{"name":"voterDictFromList","comment":" Create a voter dictionary from a list.\nFor other operations, use the `AnyDict` module directly.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"List.List ( Cardano.Gov.Voter, a ) -> Cardano.Gov.VoterDict a"},{"name":"voterFromCbor","comment":" Decoder for Voter type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.Voter"},{"name":"voterKeyCred","comment":" Helper function to extract keys that would need signing.\n","type":"Cardano.Gov.Voter -> Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Address.CredentialHash)"},{"name":"voterLedgerOrder","comment":" Helper function to help sort voters for redeemers in the same order as Haskell node.\n\nThe problem is that the ledger code sort these maps with auto derived order.\nAnd the Credential definition uses ScriptHash first, instead of VKeyHash first.\n<https://github.com/IntersectMBO/cardano-ledger/blob/2f199b94716350b5fbd6c07505eb333d89cffa90/libs/cardano-ledger-core/src/Cardano/Ledger/Credential.hs#L85>\n\n","type":"Cardano.Gov.Voter -> ( Basics.Int, String.String )"},{"name":"voterToId","comment":" Convert a Voter into a CIP-129 governance Id.\n","type":"Cardano.Gov.Voter -> Cardano.Gov.Id"},{"name":"votingProcedureFromCbor","comment":" Decoder for VotingProcedure type.\n","type":"Cbor.Decode.Decoder Cardano.Gov.VotingProcedure"}],"binops":[]},{"name":"Cardano.Interval","comment":" In a eUTxO-based blockchain like Cardano, the management of time can be finicky.\nIndeed, in order to maintain a complete determinism in the execution of scripts, it is impossible to introduce a notion of \"current time\".\nThe execution would then depend on factor that are external to the transaction itself: the ineluctable stream of time flowing in our universe.\nHence, to work around that, we typically define time intervals, within which the transaction can be executed.\nFrom within a script, it isn’t possible to know when exactly the script is executed, but we can reason about the interval bounds to validate pieces of logic.\n\n@docs Interval, Bound, BoundType\n\n","unions":[{"name":"BoundType","comment":" The bound type, which can be finite or infinite.\n","args":["a"],"cases":[["NegativeInfinity",[]],["Finite",["a"]],["PositiveInfinity",[]]]}],"aliases":[{"name":"Bound","comment":" Bound of an interval.\n","args":["a"],"type":"{ boundType : Cardano.Interval.BoundType a, isInclusive : Basics.Bool }"},{"name":"Interval","comment":" A type to represent intervals of values, with finite or infinite bounds.\n","args":["a"],"type":"{ lowerBound : Cardano.Interval.Bound a, upperBound : Cardano.Interval.Bound a }"}],"values":[],"binops":[]},{"name":"Cardano.Metadatum","comment":"\n\n@docs Metadatum, fromCbor, toCbor\n\n","unions":[{"name":"Metadatum","comment":" Transaction auxiliary data metadatum.\n","args":[],"cases":[["Int",["Integer.Integer"]],["Bytes",["Bytes.Comparable.Bytes Bytes.Comparable.Any"]],["String",["String.String"]],["List",["List.List Cardano.Metadatum.Metadatum"]],["Map",["List.List ( Cardano.Metadatum.Metadatum, Cardano.Metadatum.Metadatum )"]]]}],"aliases":[],"values":[{"name":"fromCbor","comment":" Decode Metadatum from CBOR\n","type":"Cbor.Decode.Decoder Cardano.Metadatum.Metadatum"},{"name":"toCbor","comment":" Encode Metadatum to CBOR.\n","type":"Cardano.Metadatum.Metadatum -> Cbor.Encode.Encoder"}],"binops":[]},{"name":"Cardano.MultiAsset","comment":" Handling multi-asset values.\n\n@docs MultiAsset, PolicyId, AssetName\n@docs isEmpty, get, empty, onlyToken, normalize, mintAdd\n@docs balance, map2, split\n@docs coinsToCbor, mintToCbor, coinsFromCbor, mintFromCbor\n@docs toMultilineString\n\n","unions":[{"name":"AssetName","comment":" Phantom type for asset names.\nThis is a free-form bytes array of length <= 32 bytes.\n","args":[],"cases":[]}],"aliases":[{"name":"MultiAsset","comment":" Type alias for handling multi-asset values.\n\nThis type should maintain some invariants by construction.\nIn particular, it should never contain a zero quantity of a particular token.\n\nTODO: make sure the previous statement stays true by construction.\nThis would require an opaque type for MultiAsset.\n\n","args":["int"],"type":"Bytes.Map.BytesMap Cardano.MultiAsset.PolicyId (Bytes.Map.BytesMap Cardano.MultiAsset.AssetName int)"},{"name":"PolicyId","comment":" Phantom type for 28-bytes policy id.\nThis is a Blacke2b-224 hash.\n","args":[],"type":"Cardano.Address.CredentialHash"}],"values":[{"name":"balance","comment":" Compute a mint balance.\n","type":"Bytes.Map.BytesMap Cardano.MultiAsset.AssetName Integer.Integer -> { minted : Bytes.Map.BytesMap Cardano.MultiAsset.AssetName Natural.Natural, burned : Bytes.Map.BytesMap Cardano.MultiAsset.AssetName Natural.Natural }"},{"name":"coinsFromCbor","comment":" CBOR decoder for [MultiAsset] coins.\n","type":"Cbor.Decode.Decoder (Cardano.MultiAsset.MultiAsset Natural.Natural)"},{"name":"coinsToCbor","comment":" CBOR encoder for [MultiAsset] coins.\n","type":"Cardano.MultiAsset.MultiAsset Natural.Natural -> Cbor.Encode.Encoder"},{"name":"empty","comment":" Create an empty [MultiAsset].\n","type":"Cardano.MultiAsset.MultiAsset a"},{"name":"get","comment":" Retrieve the amount of a given token.\n","type":"Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId -> Bytes.Comparable.Bytes Cardano.MultiAsset.AssetName -> Cardano.MultiAsset.MultiAsset a -> Maybe.Maybe a"},{"name":"isEmpty","comment":" Check if the [MultiAsset] contains no token.\n","type":"Cardano.MultiAsset.MultiAsset a -> Basics.Bool"},{"name":"map2","comment":" Apply a function for each token pair of two [MultiAsset].\nAbsent tokens in one [MultiAsset] are replaced by the default value.\n","type":"(a -> a -> b) -> a -> Cardano.MultiAsset.MultiAsset a -> Cardano.MultiAsset.MultiAsset a -> Cardano.MultiAsset.MultiAsset b"},{"name":"mintAdd","comment":" Add together two mint values.\n","type":"Cardano.MultiAsset.MultiAsset Integer.Integer -> Cardano.MultiAsset.MultiAsset Integer.Integer -> Cardano.MultiAsset.MultiAsset Integer.Integer"},{"name":"mintFromCbor","comment":" CBOR decoder for [MultiAsset] mints.\n","type":"Cbor.Decode.Decoder (Cardano.MultiAsset.MultiAsset Integer.Integer)"},{"name":"mintToCbor","comment":" CBOR encoder for [MultiAsset] mints.\n","type":"Cardano.MultiAsset.MultiAsset Integer.Integer -> Cbor.Encode.Encoder"},{"name":"normalize","comment":" Remove assets with 0 amounts.\n","type":"(int -> Basics.Bool) -> Cardano.MultiAsset.MultiAsset int -> Cardano.MultiAsset.MultiAsset int"},{"name":"onlyToken","comment":" Create a singleton [MultiAsset].\n","type":"Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId -> Bytes.Comparable.Bytes Cardano.MultiAsset.AssetName -> int -> Cardano.MultiAsset.MultiAsset int"},{"name":"split","comment":" Split a [MultiAsset] into a list of each individual asset `(policyId, assetName, amount)`.\n","type":"Cardano.MultiAsset.MultiAsset a -> List.List ( Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId, Bytes.Comparable.Bytes Cardano.MultiAsset.AssetName, a )"},{"name":"toMultilineString","comment":" Helper function to display `MultiAsset`.\n","type":"(a -> String.String) -> Cardano.MultiAsset.MultiAsset a -> List.List String.String"}],"binops":[]},{"name":"Cardano.Pool","comment":" Handling Cardano values.\n\n@docs Id, toBech32, fromBech32\n\n@docs Params, VrfKeyHash, Relay, IpV4, IpV6\n\n@docs Metadata, MetadataHash\n\n@docs encodeParams, decodeParams\n\n","unions":[{"name":"IpV4","comment":" Phantom type for 4-bytes IPV4 addresses.\n","args":[],"cases":[]},{"name":"IpV6","comment":" Phantom type for 16-bytes IPV6 addresses.\n","args":[],"cases":[]},{"name":"MetadataHash","comment":" Phantom type for 32-bytes pool metadata hash.\nThis is a Blacke2b-256 hash.\n","args":[],"cases":[]},{"name":"Relay","comment":" A pool's relay information.\n","args":[],"cases":[["SingleHostAddr",["{ port_ : Maybe.Maybe Basics.Int, ipv4 : Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Pool.IpV4), ipv6 : Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Pool.IpV6) }"]],["SingleHostName",["{ port_ : Maybe.Maybe Basics.Int, dnsName : String.String }"]],["MultiHostName",["{ dnsName : String.String }"]]]},{"name":"VrfKeyHash","comment":" Phantom type for VRF key hash.\nThis is a 32-bytes Blake2b-256 hash.\n","args":[],"cases":[]}],"aliases":[{"name":"Id","comment":" Phantom type for pool ID.\nThis is a 28-bytes Blake2b-224 hash.\n","args":[],"type":"Cardano.Address.CredentialHash"},{"name":"Metadata","comment":" A pool's metadata hash.\n","args":[],"type":"{ url : String.String, poolMetadataHash : Bytes.Comparable.Bytes Cardano.Pool.MetadataHash }"},{"name":"Params","comment":" Parameters for stake pool registration.\n","args":[],"type":"{ operator : Bytes.Comparable.Bytes Cardano.Pool.Id, vrfKeyHash : Bytes.Comparable.Bytes Cardano.Pool.VrfKeyHash, pledge : Natural.Natural, cost : Natural.Natural, margin : Cardano.Utils.UnitInterval, rewardAccount : Cardano.Address.StakeAddress, poolOwners : List.List (Bytes.Comparable.Bytes Cardano.Address.CredentialHash), relays : List.List Cardano.Pool.Relay, poolMetadata : Maybe.Maybe Cardano.Pool.Metadata }"}],"values":[{"name":"decodeParams","comment":" Decode all Pool parameters.\n","type":"Cbor.Decode.Decoder Cardano.Pool.Params"},{"name":"encodeParams","comment":" Encode all Pool parameters.\n","type":"Cardano.Pool.Params -> List.List Cbor.Encode.Encoder"},{"name":"fromBech32","comment":" Convert a Pool Id from its Bech32 representation.\n","type":"String.String -> Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Pool.Id)"},{"name":"toBech32","comment":" Convert a Pool Id to its Bech32 representation.\n","type":"Bytes.Comparable.Bytes Cardano.Pool.Id -> String.String"}],"binops":[]},{"name":"Cardano.Redeemer","comment":" Redeemer\n\n@docs Redeemer, RedeemerTag, ExUnits\n@docs ExUnitPrices, feeCost, decodeExUnitPrices, encodeExUnitPrices\n@docs encodeAsArray, encodeTag, encodeExUnits\n@docs fromCborArray, tagFromCbor, exUnitsFromCbor\n\n","unions":[{"name":"RedeemerTag","comment":" Indicator of the type of validator associated with this redeemer.\n","args":[],"cases":[["Spend",[]],["Mint",[]],["Cert",[]],["Reward",[]],["Vote",[]],["Propose",[]]]}],"aliases":[{"name":"ExUnitPrices","comment":" Represents execution unit prices.\n","args":[],"type":"{ memPrice : Cardano.Utils.RationalNumber, stepPrice : Cardano.Utils.RationalNumber }"},{"name":"ExUnits","comment":" Cost of the script in memory and instruction steps.\n","args":[],"type":"{ mem : Basics.Int, steps : Basics.Int }"},{"name":"Redeemer","comment":" Redeemer of a script, containing the data passed as argument to the validator.\n","args":[],"type":"{ tag : Cardano.Redeemer.RedeemerTag, index : Basics.Int, data : Cardano.Data.Data, exUnits : Cardano.Redeemer.ExUnits }"}],"values":[{"name":"decodeExUnitPrices","comment":" Decoder for ExUnitPrices type.\n","type":"Cbor.Decode.Decoder Cardano.Redeemer.ExUnitPrices"},{"name":"encodeAsArray","comment":" CBOR encoder for a [Redeemer].\n","type":"Cardano.Redeemer.Redeemer -> Cbor.Encode.Encoder"},{"name":"encodeExUnitPrices","comment":" Encoder for ExUnitPrices type.\n","type":"Cardano.Redeemer.ExUnitPrices -> Cbor.Encode.Encoder"},{"name":"encodeExUnits","comment":" CBOR encoder for [ExUnits].\n","type":"Cardano.Redeemer.ExUnits -> Cbor.Encode.Encoder"},{"name":"encodeTag","comment":" CBOR encoder for a [RedeemerTag].\n","type":"Cardano.Redeemer.RedeemerTag -> Cbor.Encode.Encoder"},{"name":"exUnitsFromCbor","comment":" CBOR decoder for [ExUnits].\n","type":"Cbor.Decode.Decoder Cardano.Redeemer.ExUnits"},{"name":"feeCost","comment":" Helper function to compute a give redeemer cost in fees.\n","type":"Cardano.Redeemer.ExUnitPrices -> Cardano.Redeemer.ExUnits -> Natural.Natural"},{"name":"fromCborArray","comment":" CBOR decoder for [Redeemer].\n","type":"Cbor.Decode.Decoder Cardano.Redeemer.Redeemer"},{"name":"tagFromCbor","comment":" CBOR decoder for [Tag].\n","type":"Cbor.Decode.Decoder Cardano.Redeemer.RedeemerTag"}],"binops":[]},{"name":"Cardano.Script","comment":" Script\n\n@docs Script, NativeScript, PlutusScript, PlutusVersion, ScriptCbor, extractSigners, isMultisigSatisfied, hash, fromBech32, toBech32\n\n@docs Reference, refFromBytes, refFromScript, refBytes, refScript, refHash\n\n\n## Scripts and Bytes\n\n@docs nativeScriptFromBytes, nativeScriptBytes\n\n@docs plutusScriptFromBytes, plutusVersion, cborWrappedBytes\n\n\n## CBOR Encoders\n\n@docs toCbor, encodeNativeScript\n\n\n## CBOR and JSON Decoders\n\n@docs fromCbor, decodeNativeScript, jsonDecodeNativeScript\n\n","unions":[{"name":"NativeScript","comment":" A native script\n<https://github.com/txpipe/pallas/blob/d1ac0561427a1d6d1da05f7b4ea21414f139201e/pallas-primitives/src/alonzo/model.rs#L772>\n","args":[],"cases":[["ScriptPubkey",["Bytes.Comparable.Bytes Cardano.Address.CredentialHash"]],["ScriptAll",["List.List Cardano.Script.NativeScript"]],["ScriptAny",["List.List Cardano.Script.NativeScript"]],["ScriptNofK",["Basics.Int","List.List Cardano.Script.NativeScript"]],["InvalidBefore",["Natural.Natural"]],["InvalidHereafter",["Natural.Natural"]]]},{"name":"PlutusScript","comment":" A plutus script.\n","args":[],"cases":[]},{"name":"PlutusVersion","comment":" The plutus version.\n","args":[],"cases":[["PlutusV1",[]],["PlutusV2",[]],["PlutusV3",[]]]},{"name":"Reference","comment":" Script Reference type, to be used to store a script into UTxOs.\nInternally, it also stores the Bytes version of the script to later have correct fees computations.\n","args":[],"cases":[]},{"name":"Script","comment":" Cardano script, either a native script or a plutus script.\n\n`script = [ 0, native_script // 1, plutus_v1_script // 2, plutus_v2_script ]`\n\n[Babbage implementation in Pallas][pallas].\n\n[pallas]: https://github.com/txpipe/pallas/blob/d1ac0561427a1d6d1da05f7b4ea21414f139201e/pallas-primitives/src/babbage/model.rs#L58\n\n","args":[],"cases":[["Native",["Cardano.Script.NativeScript"]],["Plutus",["Cardano.Script.PlutusScript"]]]},{"name":"ScriptCbor","comment":" Phantom type describing the kind of bytes within a [PlutusScript] object.\nThey are supposed to be the Flat bytes wrapped into a single CBOR byte string.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"cborWrappedBytes","comment":" Extract the script bytes, wrapped in a CBOR byte string,\nSo basically the same thing that you would get in the `plutus.json` blueprint file.\n\nThis is returning: `cbor_bytes(flat_bytes)`.\n\n","type":"Cardano.Script.PlutusScript -> Bytes.Comparable.Bytes Cardano.Script.ScriptCbor"},{"name":"decodeNativeScript","comment":" Decode NativeScript from CBOR.\n","type":"Cbor.Decode.Decoder Cardano.Script.NativeScript"},{"name":"encodeNativeScript","comment":" Cbor Encoder for [NativeScript]\n","type":"Cardano.Script.NativeScript -> Cbor.Encode.Encoder"},{"name":"extractSigners","comment":" Extract all mentionned pubkeys in the Native script.\nKeys of the dict are the hex version of the keys.\n","type":"Cardano.Script.NativeScript -> Dict.Dict String.String (Bytes.Comparable.Bytes Cardano.Address.CredentialHash)"},{"name":"fromBech32","comment":" Convert a script hash from its Bech32 representation.\n","type":"String.String -> Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Address.CredentialHash)"},{"name":"fromCbor","comment":" CBOR decoder for [Script].\n\nThis does not contain the double CBOR decoding of the `script_ref` UTxO field.\nThat part has to be handled in the UTxO decoder.\n\n","type":"Cbor.Decode.Decoder Cardano.Script.Script"},{"name":"hash","comment":" Compute the script hash.\n\nThe script type tag must be prepended before hashing,\nbut not encapsulated as a list to make a valid CBOR struct.\nThis is not valid CBOR, just concatenation of tag|scriptBytes.\n\n","type":"Cardano.Script.Script -> Bytes.Comparable.Bytes Cardano.Address.CredentialHash"},{"name":"isMultisigSatisfied","comment":" Validate the multisig logic with the provided signers.\nThe temporal aspect of the script is not considered (evaluates True).\n","type":"List.List (Bytes.Comparable.Bytes Cardano.Address.CredentialHash) -> Cardano.Script.NativeScript -> Basics.Bool"},{"name":"jsonDecodeNativeScript","comment":" Decode NativeScript from its JSON node specification.\n\n<https://github.com/IntersectMBO/cardano-node/blob/40ebadd4b70530f89fe76513c108a1a356ad16ea/doc/reference/simple-scripts.md#type-after>\n\n","type":"Json.Decode.Decoder Cardano.Script.NativeScript"},{"name":"nativeScriptBytes","comment":" Get the bytes representation of a native script.\n\nThis is just a helper function doing the following:\n\n    nativeScriptBytes nativeScript =\n        encodeNativeScript nativeScript\n            |> Cbor.Encode.encode\n            |> Bytes.fromBytes\n\n","type":"Cardano.Script.NativeScript -> Bytes.Comparable.Bytes a"},{"name":"nativeScriptFromBytes","comment":" Decode a native script from its bytes representation.\n\nThis is just a helper function doing the following:\n\n    Cbor.Decode.decode decodeNativeScript (Bytes.toBytes bytes)\n\n","type":"Bytes.Comparable.Bytes a -> Maybe.Maybe Cardano.Script.NativeScript"},{"name":"plutusScriptFromBytes","comment":" Create a PlutusScript from its bytes representation.\n\nDepending on where the bytes come from, they can have many different shapes.\nAt the lowest level, Plutus scripts are encoded with a format called [Flat][flat].\nBut since Cardano uses CBOR everywhere else, the Flat bytes are usually wrapped in a CBOR byte string.\nBut that’s not the only shape they can have.\nIndeed, when transmitted in transactions like in a UTxO script reference,\nthey are usually packed into a pair containing an integer tag for the Plutus version,\nand the CBOR bytes themselves, re-encoded as Bytes in the pair!\nMeaning the script Flat bytes might get a double CBOR byte wrap.\n\nAnd if that wasn’t confusing enough, when computing the hash of a Plutus script,\nit’s not even the above CBOR tagged pair that is used.\nInstead it is the raw concatenation of the tag and the single-wrapped Flat bytes.\n\nSummary, with pseudo-code:\n\n1.  `flat_bytes`: the actual Plutus script bytes.\n2.  `cbor_bytes(flat_bytes)`: the thing that is provided in the `plutus.json` blueprint of an Aiken compilation.\n3.  `cbor_bytes(cbor_bytes(flat_bytes))`: how encoded in the witness set and by some CLI tools.\n4.  `tag + cbor_bytes(flat_bytes)`: the input of the Blake2b-224 hash to compute the script hash.\n5.  `cbor_array[cbor_int(tag), cbor_bytes(cbor_bytes(flat_bytes))]`: the thing transmitted in UTxO script references.\n\nIt’s confusing and error prone, so we made the `PlutusScript` type opaque,\nand you basically need to call this function to convert from bytes,\nwhich will smartly figure it out.\n\nWARNING: This function is only for shapes (1, 2, 3).\nShape (4) is never used except temporarily to compute hashes.\nShape (5) is supposed to be decoded with the `Script.fromCbor` decoder:\n`D.decode Script.fromCbor scriptCborBytes`.\n\nIf no particular shape is recognized, this function will assume the whole bytes are the Flat bytes,\nbecause we don’t have a Flat decoder in Elm.\n\n[flat]: https://quid2.org/docs/Flat.pdf\n\n","type":"Cardano.Script.PlutusVersion -> Bytes.Comparable.Bytes a -> Cardano.Script.PlutusScript"},{"name":"plutusVersion","comment":" Extract the PlutusVersion from a PlutusScript.\n","type":"Cardano.Script.PlutusScript -> Cardano.Script.PlutusVersion"},{"name":"refBytes","comment":" Extract the Bytes from a script Reference.\n\nIf the script was encoded as would elm-cardano,\nthis would be equivalent to calling `Bytes.fromBytes <| encode (toCbor script)`\n\n","type":"Cardano.Script.Reference -> Bytes.Comparable.Bytes Cardano.Script.Script"},{"name":"refFromBytes","comment":" Create a Script Reference from the script bytes.\nReturns Nothing if the bytes are not a valid script.\n","type":"Bytes.Comparable.Bytes Cardano.Script.Script -> Maybe.Maybe Cardano.Script.Reference"},{"name":"refFromScript","comment":" Create a Script Reference from a Script (using elm-cardano encoding approach).\n","type":"Cardano.Script.Script -> Cardano.Script.Reference"},{"name":"refHash","comment":" Extract the Script hash from the script Reference.\n","type":"Cardano.Script.Reference -> Bytes.Comparable.Bytes Cardano.Address.CredentialHash"},{"name":"refScript","comment":" Extract the Script from a script Reference.\n","type":"Cardano.Script.Reference -> Maybe.Maybe Cardano.Script.Script"},{"name":"toBech32","comment":" Convert a script hash to its Bech32 representation.\n","type":"Bytes.Comparable.Bytes Cardano.Address.CredentialHash -> String.String"},{"name":"toCbor","comment":" Cbor Encoder for [Script]\n","type":"Cardano.Script.Script -> Cbor.Encode.Encoder"}],"binops":[]},{"name":"Cardano.Transaction","comment":" Types and functions related to on-chain transactions.\n\n@docs Transaction, new\n\n@docs TransactionBody, newBody, ScriptDataHash\n\n@docs WitnessSet, newWitnessSet\n\n@docs Update\n\n@docs ScriptContext, ScriptPurpose\n\n@docs Certificate, GenesisHash, GenesisDelegateHash, RewardSource, RewardTarget, MoveInstantaneousReward\n\n@docs VKeyWitness, hashVKey, BootstrapWitness, Ed25519PublicKey, Ed25519Signature, BootstrapWitnessChainCode, BootstrapWitnessAttributes\n\n@docs FeeParameters, RefScriptFeeParameters, defaultTxFeeParams, computeFees, computeRefScriptFee, computeScriptExecFee, computeTxSizeFee, estimateRefScriptFeeSavings\n\n@docs allInputs\n\n@docs computeTxId, locateScriptWithHash\n\n@docs updateSignatures, hashScriptData\n\n@docs deserialize, serialize, encodeToCbor\n\n@docs decodeWitnessSet, decodeVKeyWitness, encodeVKeyWitness\n\n","unions":[{"name":"BootstrapWitnessAttributes","comment":" Phantom type for [BootstrapWitness] attributes.\nBytes of this type can be of any length.\n","args":[],"cases":[]},{"name":"BootstrapWitnessChainCode","comment":" Phantom type for [BootstrapWitness] chain code.\nIt has a length of 32 bytes.\n","args":[],"cases":[]},{"name":"Certificate","comment":" An on-chain certificate attesting of some operation.\nPublishing certificates triggers different kind of rules.\nMost of the time, they require signatures from specific keys.\n","args":[],"cases":[["StakeRegistrationCert",["{ delegator : Cardano.Address.Credential }"]],["StakeDeregistrationCert",["{ delegator : Cardano.Address.Credential }"]],["StakeDelegationCert",["{ delegator : Cardano.Address.Credential, poolId : Bytes.Comparable.Bytes Cardano.Pool.Id }"]],["PoolRegistrationCert",["Cardano.Pool.Params"]],["PoolRetirementCert",["{ poolId : Bytes.Comparable.Bytes Cardano.Pool.Id, epoch : Natural.Natural }"]],["GenesisKeyDelegationCert",["{ genesisHash : Bytes.Comparable.Bytes Cardano.Transaction.GenesisHash, genesisDelegateHash : Bytes.Comparable.Bytes Cardano.Transaction.GenesisDelegateHash, vrfKeyHash : Bytes.Comparable.Bytes Cardano.Pool.VrfKeyHash }"]],["MoveInstantaneousRewardsCert",["Cardano.Transaction.MoveInstantaneousReward"]],["RegCert",["{ delegator : Cardano.Address.Credential, deposit : Natural.Natural }"]],["UnregCert",["{ delegator : Cardano.Address.Credential, refund : Natural.Natural }"]],["VoteDelegCert",["{ delegator : Cardano.Address.Credential, drep : Cardano.Gov.Drep }"]],["StakeVoteDelegCert",["{ delegator : Cardano.Address.Credential, poolId : Bytes.Comparable.Bytes Cardano.Pool.Id, drep : Cardano.Gov.Drep }"]],["StakeRegDelegCert",["{ delegator : Cardano.Address.Credential, poolId : Bytes.Comparable.Bytes Cardano.Pool.Id, deposit : Natural.Natural }"]],["VoteRegDelegCert",["{ delegator : Cardano.Address.Credential, drep : Cardano.Gov.Drep, deposit : Natural.Natural }"]],["StakeVoteRegDelegCert",["{ delegator : Cardano.Address.Credential, poolId : Bytes.Comparable.Bytes Cardano.Pool.Id, drep : Cardano.Gov.Drep, deposit : Natural.Natural }"]],["AuthCommitteeHotCert",["{ committeeColdCredential : Cardano.Address.Credential, committeeHotCredential : Cardano.Address.Credential }"]],["ResignCommitteeColdCert",["{ committeeColdCredential : Cardano.Address.Credential, anchor : Maybe.Maybe Cardano.Gov.Anchor }"]],["RegDrepCert",["{ drepCredential : Cardano.Address.Credential, deposit : Natural.Natural, anchor : Maybe.Maybe Cardano.Gov.Anchor }"]],["UnregDrepCert",["{ drepCredential : Cardano.Address.Credential, refund : Natural.Natural }"]],["UpdateDrepCert",["{ drepCredential : Cardano.Address.Credential, anchor : Maybe.Maybe Cardano.Gov.Anchor }"]]]},{"name":"Ed25519PublicKey","comment":" Phantom type for ED25519 public keys, of length 32 bytes.\n","args":[],"cases":[]},{"name":"Ed25519Signature","comment":" Phantom type for ED25519 signatures, of length 64 bytes.\n","args":[],"cases":[]},{"name":"GenesisDelegateHash","comment":" Phantom type for Genesis delegate hash.\nThis is a 28-bytes Blake2b-224 hash.\n","args":[],"cases":[]},{"name":"GenesisHash","comment":" Phantom type for Genesis hash.\nThis is a 28-bytes Blake2b-224 hash.\n","args":[],"cases":[]},{"name":"RewardSource","comment":" The source of rewards.\n","args":[],"cases":[["Reserves",[]],["Treasury",[]]]},{"name":"RewardTarget","comment":" Reward target for a certificate's [MoveInstantaneousReward].\n\nIf `StakeCredentials`, funds are moved to stake credentials,\notherwise the funds are given to the other accounting pot.\n\n","args":[],"cases":[["StakeCredentials",["List.List ( Cardano.Address.Credential, Natural.Natural )"]],["OtherAccountingPot",["Natural.Natural"]]]},{"name":"ScriptDataHash","comment":" Phantom type for script data hashes.\nThis is a 32-bytes Blake2b-256 hash.\n","args":[],"cases":[]},{"name":"ScriptPurpose","comment":" Characterizes the kind of script being executed and the associated resource.\n","args":[],"cases":[["SPMint",["{ policyId : Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId }"]],["SPSpend",["Cardano.Utxo.OutputReference"]],["SPWithdrawFrom",["Cardano.Address.Credential"]],["SPPublish",["Cardano.Transaction.Certificate"]]]}],"aliases":[{"name":"BootstrapWitness","comment":" Bootstrap witness\n","args":[],"type":"{ publicKey : Bytes.Comparable.Bytes Cardano.Transaction.Ed25519PublicKey, signature : Bytes.Comparable.Bytes Cardano.Transaction.Ed25519Signature, chainCode : Bytes.Comparable.Bytes Cardano.Transaction.BootstrapWitnessChainCode, attributes : Bytes.Comparable.Bytes Cardano.Transaction.BootstrapWitnessAttributes }"},{"name":"FeeParameters","comment":" Parameters required to compute transaction fees.\n","args":[],"type":"{ baseFee : Basics.Int, feePerByte : Basics.Int, scriptExUnitPrice : Cardano.Redeemer.ExUnitPrices, refScriptFeeParams : Cardano.Transaction.RefScriptFeeParameters }"},{"name":"MoveInstantaneousReward","comment":" Payload for [MoveInstantaneousRewardsCert].\n","args":[],"type":"{ source : Cardano.Transaction.RewardSource, target : Cardano.Transaction.RewardTarget }"},{"name":"RefScriptFeeParameters","comment":" Parameters for the costs of referencing scripts.\n\nFull explanation of the formula here:\n<https://github.com/IntersectMBO/cardano-ledger/blob/master/docs/adr/2024-08-14_009-refscripts-fee-change.md>\n\n","args":[],"type":"{ minFeeRefScriptCostPerByte : Basics.Int, multiplier : Cardano.Utils.RationalNumber, sizeIncrement : Basics.Int }"},{"name":"ScriptContext","comment":" A context given to a script by the Cardano ledger when being executed.\n\nThe context contains information about the entire transaction that contains the script.\nThe transaction may also contain other scripts.\nTo distinguish between multiple scripts, the ScriptContext contains a \"purpose\" identifying the current resource triggering this execution.\n\n","args":[],"type":"{ transaction : Cardano.Transaction.Transaction, purpose : Cardano.Transaction.ScriptPurpose }"},{"name":"Transaction","comment":" A Cardano transaction.\n","args":[],"type":"{ body : Cardano.Transaction.TransactionBody, witnessSet : Cardano.Transaction.WitnessSet, isValid : Basics.Bool, auxiliaryData : Maybe.Maybe Cardano.AuxiliaryData.AuxiliaryData }"},{"name":"TransactionBody","comment":" A Cardano transaction body.\n","args":[],"type":"{ inputs : List.List Cardano.Utxo.OutputReference, outputs : List.List Cardano.Utxo.Output, fee : Natural.Natural, ttl : Maybe.Maybe Natural.Natural, certificates : List.List Cardano.Transaction.Certificate, withdrawals : List.List ( Cardano.Address.StakeAddress, Natural.Natural ), update : Maybe.Maybe Cardano.Transaction.Update, auxiliaryDataHash : Maybe.Maybe (Bytes.Comparable.Bytes Cardano.AuxiliaryData.Hash), validityIntervalStart : Maybe.Maybe Basics.Int, mint : Cardano.MultiAsset.MultiAsset Integer.Integer, scriptDataHash : Maybe.Maybe (Bytes.Comparable.Bytes Cardano.Transaction.ScriptDataHash), collateral : List.List Cardano.Utxo.OutputReference, requiredSigners : List.List (Bytes.Comparable.Bytes Cardano.Address.CredentialHash), networkId : Maybe.Maybe Cardano.Address.NetworkId, collateralReturn : Maybe.Maybe Cardano.Utxo.Output, totalCollateral : Maybe.Maybe Basics.Int, referenceInputs : List.List Cardano.Utxo.OutputReference, votingProcedures : List.List ( Cardano.Gov.Voter, List.List ( Cardano.Gov.ActionId, Cardano.Gov.VotingProcedure ) ), proposalProcedures : List.List Cardano.Gov.ProposalProcedure, currentTreasuryValue : Maybe.Maybe Natural.Natural, treasuryDonation : Maybe.Maybe Natural.Natural }"},{"name":"Update","comment":" Payload to update the protocol parameters at a specific epoch\n","args":[],"type":"{ proposedProtocolParameterUpdates : Bytes.Map.BytesMap Cardano.Transaction.GenesisHash Cardano.Gov.ProtocolParamUpdate, epoch : Natural.Natural }"},{"name":"VKeyWitness","comment":" VKey witness\n","args":[],"type":"{ vkey : Bytes.Comparable.Bytes Cardano.Transaction.Ed25519PublicKey, signature : Bytes.Comparable.Bytes Cardano.Transaction.Ed25519Signature }"},{"name":"WitnessSet","comment":" A Cardano transaction witness set.\n\n[Pallas alonzo implementation][pallas]\n\n[pallas]: https://github.com/txpipe/pallas/blob/d1ac0561427a1d6d1da05f7b4ea21414f139201e/pallas-primitives/src/alonzo/model.rs#L763\n\n","args":[],"type":"{ vkeywitness : Maybe.Maybe (List.List Cardano.Transaction.VKeyWitness), nativeScripts : Maybe.Maybe (List.List Cardano.Script.NativeScript), bootstrapWitness : Maybe.Maybe (List.List Cardano.Transaction.BootstrapWitness), plutusV1Script : Maybe.Maybe (List.List (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor)), plutusData : Maybe.Maybe (List.List Cardano.Data.Data), redeemer : Maybe.Maybe (List.List Cardano.Redeemer.Redeemer), plutusV2Script : Maybe.Maybe (List.List (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor)), plutusV3Script : Maybe.Maybe (List.List (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor)) }"}],"values":[{"name":"allInputs","comment":" Extract all inputs that are used in the transaction,\nfrom inputs, collateral and reference inputs.\n","type":"Cardano.Transaction.Transaction -> Cardano.Utxo.RefDict ()"},{"name":"computeFees","comment":" Re-compute fees for a transaction (does not read `body.fee`).\n","type":"Cardano.Transaction.FeeParameters -> { refScriptBytes : Basics.Int } -> Cardano.Transaction.Transaction -> { txSizeFee : Natural.Natural, scriptExecFee : Natural.Natural, refScriptSizeFee : Natural.Natural }"},{"name":"computeRefScriptFee","comment":" Helper function to compute the fees associated with reference script size.\n\nFull explanation of the formula here:\n<https://github.com/IntersectMBO/cardano-ledger/blob/master/docs/adr/2024-08-14_009-refscripts-fee-change.md>\n\n```haskell\ntierRefScriptFee = go 0 minFeeRefScriptCostPerByte\n  where\n    go acc curTierPrice n\n      | n < sizeIncrement =\n          floor (acc + (n % 1) * curTierPrice)\n      | otherwise =\n          let acc' = acc + curTierPrice * (sizeIncrement % 1)\n           in go acc' (multiplier * curTierPrice) (n - sizeIncrement)\n    sizeIncrement = 25600\n    multiplier = 1.2\n    minFeeRefScriptCostPerByte = 15\n```\n\n","type":"Cardano.Transaction.RefScriptFeeParameters -> Basics.Int -> Natural.Natural"},{"name":"computeScriptExecFee","comment":" Compute the part of the fees of a Transaction related to the execution of scripts in the Plutus VM.\n","type":"Cardano.Redeemer.ExUnitPrices -> Cardano.Transaction.Transaction -> Natural.Natural"},{"name":"computeTxId","comment":" Serialize the body and compute the Tx ID.\n","type":"Cardano.Transaction.Transaction -> Bytes.Comparable.Bytes Cardano.Utxo.TransactionId"},{"name":"computeTxSizeFee","comment":" Compute the part of the fees of a Transaction directly related to the Tx size in bytes.\n\nThe \"baseFee\" and \"feePerByte\" are network parameters.\n\n","type":"{ a | baseFee : Basics.Int, feePerByte : Basics.Int } -> Cardano.Transaction.Transaction -> Natural.Natural"},{"name":"decodeVKeyWitness","comment":" Decode from CBOR one VKey witness signature.\n","type":"Cbor.Decode.Decoder Cardano.Transaction.VKeyWitness"},{"name":"decodeWitnessSet","comment":" Decode a [WitnessSet] from CBOR.\n","type":"Cbor.Decode.Decoder Cardano.Transaction.WitnessSet"},{"name":"defaultTxFeeParams","comment":" Default values for fee parameters.\n","type":"Cardano.Transaction.FeeParameters"},{"name":"deserialize","comment":" Deserialize a transaction's cbor bytes into a [Transaction]\n","type":"Bytes.Comparable.Bytes a -> Maybe.Maybe Cardano.Transaction.Transaction"},{"name":"encodeToCbor","comment":" Encode a Tx to CBOR\n","type":"Cardano.Transaction.Transaction -> Cbor.Encode.Encoder"},{"name":"encodeVKeyWitness","comment":" Encode to CBOR one VKey signatures.\n","type":"Cardano.Transaction.VKeyWitness -> Cbor.Encode.Encoder"},{"name":"estimateRefScriptFeeSavings","comment":" Estimate the potential saving in transaction fees by passing a script by reference\ninstead of putting inline in the Tx witnesses.\n","type":"Cardano.Script.Script -> Basics.Int"},{"name":"hashScriptData","comment":" Compute the script data hash of the transaction.\n\nThe caller must know what versions of Plutus scripts are present in the Tx\nand provide accordingly the associated cost models.\n\nScript data is serialized in a very specific way to compute the hash.\nSee Conway CDDL format: <https://github.com/IntersectMBO/cardano-ledger/blob/676ffc5c3e0dddb2b1ddeb76627541b195fefb5a/eras/conway/impl/cddl-files/conway.cddl#L197>\n\n","type":"Cardano.Gov.CostModels -> Cardano.Transaction.Transaction -> Bytes.Comparable.Bytes Cardano.Transaction.ScriptDataHash"},{"name":"hashVKey","comment":" Compute the 28-bytes Blake2b hash of a public key.\n","type":"Bytes.Comparable.Bytes Cardano.Transaction.Ed25519PublicKey -> Bytes.Comparable.Bytes Cardano.Address.CredentialHash"},{"name":"locateScriptWithHash","comment":" Helper function to locate the index of a script within a list of Outputs.\n","type":"Bytes.Comparable.Bytes Cardano.Address.CredentialHash -> List.List Cardano.Utxo.Output -> Maybe.Maybe ( Basics.Int, Cardano.Script.Reference )"},{"name":"new","comment":" Helper for empty [Transaction] initialization.\n","type":"Cardano.Transaction.Transaction"},{"name":"newBody","comment":" Helper for empty transaction body initialization.\n","type":"Cardano.Transaction.TransactionBody"},{"name":"newWitnessSet","comment":" Helper for empty witness set initialization.\n","type":"Cardano.Transaction.WitnessSet"},{"name":"serialize","comment":" Serialize a [Transaction] into cbor bytes\n","type":"Cardano.Transaction.Transaction -> Bytes.Comparable.Bytes Cardano.Transaction.Transaction"},{"name":"updateSignatures","comment":" Clear all signatures from the witness set of the Tx.\n","type":"(Maybe.Maybe (List.List Cardano.Transaction.VKeyWitness) -> Maybe.Maybe (List.List Cardano.Transaction.VKeyWitness)) -> Cardano.Transaction.Transaction -> Cardano.Transaction.Transaction"}],"binops":[]},{"name":"Cardano.TxContext","comment":" Context available to the Tx builder to create redeemers and datums.\nVery similar to the Plutus script context, but available offchain.\n\n@docs TxContext, new, fromTx, updateInputsOutputs\n\n","unions":[],"aliases":[{"name":"TxContext","comment":" Some context available to the Tx builder to create redeemers and datums.\n\nThe contents of the `TxContext` are very similar to those of the Plutus script context.\nThis is because the goal is to help pre-compute offchain elements that will make\nonchain code more efficient.\n\nFor example, you could pre-compute indexes of elements in inputs list,\nor the redeemers list in the script context for faster onchain lookups.\nFor this reason, lists in this `TxContext` are ordered the same as in the Plutus script context.\n\n","args":[],"type":"{ fee : Natural.Natural, validityRange : { start : Maybe.Maybe Basics.Int, end : Maybe.Maybe Natural.Natural }, inputs : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), referenceInputs : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), outputs : List.List Cardano.Utxo.Output, mint : Cardano.MultiAsset.MultiAsset Integer.Integer, certificates : List.List Cardano.Transaction.Certificate, withdrawals : List.List ( Cardano.Address.StakeAddress, Natural.Natural ), votes : List.List ( Cardano.Gov.Voter, List.List ( Cardano.Gov.ActionId, Cardano.Gov.VotingProcedure ) ), proposals : List.List Cardano.Gov.ProposalProcedure, requiredSigners : List.List (Bytes.Comparable.Bytes Cardano.Address.CredentialHash), redeemers : List.List Cardano.Redeemer.Redeemer, currentTreasuryValue : Maybe.Maybe Natural.Natural, treasuryDonation : Maybe.Maybe Natural.Natural }"}],"values":[{"name":"fromTx","comment":" Create a TxContext from a pre-existing transaction.\n\nWARNING: currently, this function makes the assumption\nthat all `List` fields in the transaction are already sorted correctly.\nThis assumption is valid within the Tx builder.\n\n","type":"Cardano.Utxo.RefDict Cardano.Utxo.Output -> Cardano.Transaction.Transaction -> Cardano.TxContext.TxContext"},{"name":"new","comment":" Empty TxContext for initializations.\n","type":"Cardano.TxContext.TxContext"},{"name":"updateInputsOutputs","comment":" Helper function to update the TxContext inputs and outputs after coin selection.\n\nReference inputs do not change with UTxO selection, only spent inputs.\nInputs are sorted by output ref.\n\n","type":"{ preSelectedInputs : Cardano.Utxo.RefDict Cardano.Utxo.Output, preCreatedOutputs : Cardano.TxContext.TxContext -> { sum : Cardano.Value.Value, outputs : List.List Cardano.Utxo.Output } } -> { selectedUtxos : Cardano.Utxo.RefDict Cardano.Utxo.Output, changeOutputs : List.List Cardano.Utxo.Output } -> Cardano.TxContext.TxContext -> Cardano.TxContext.TxContext"}],"binops":[]},{"name":"Cardano.TxIntent","comment":" Building Cardano Transactions with Intents.\n\n\n# Transaction Building Overview\n\nThis framework aims to provide intuitive and correct building blocks\nfor transaction building, based on the following aspects of transactions.\n\n1.  Intent: what we want to achieve with this transaction\n      - Transfer: send some tokens from somewhere to somewhere else\n      - Mint and burn: create and destroy tokens\n      - Use a script: provide/spend tokens and data to/from a script\n      - Stake management: collect rewards, manage delegations and pool registrations\n      - Voting: vote on proposals\n      - Propose: make your own proposals\n2.  Metadata: additional information\n3.  Constraints: what additional constraints do we want to set\n      - Temporal validity range: first/last slots when the Tx is valid\n4.  Requirements: what is imposed by the protocol\n      - Tx fee: depends on size/mem/cpu\n      - Hashes: for metadata and script data\n      - Collateral: for plutus scripts\n      - Signatures: for consuming inputs and scripts requirements\n\nThis API revolves around composing intents, then adding metadata and constraints,\nand finally trying to validate it and auto-populate all requirements.\n\n\n# Code Documentation\n\n@docs balance, finalize, finalizeAdvanced, TxFinalized, TxFinalizationError, errorToString\n@docs TxIntent, SpendSource\n@docs CertificateIntent\n@docs VoteIntent, ProposalIntent, ActionProposal\n@docs TxOtherInfo\n@docs Fee\n@docs GovernanceState, emptyGovernanceState\n@docs updateLocalState\n\n","unions":[{"name":"ActionProposal","comment":" The different kinds of proposals available for governance.\n","args":[],"cases":[["ParameterChange",["Cardano.Gov.ProtocolParamUpdate"]],["HardForkInitiation",["Cardano.Gov.ProtocolVersion"]],["TreasuryWithdrawals",["List.List { destination : Cardano.Address.StakeAddress, amount : Natural.Natural }"]],["NoConfidence",[]],["UpdateCommittee",["{ removeMembers : List.List Cardano.Address.Credential, addMembers : List.List { newMember : Cardano.Address.Credential, expirationEpoch : Natural.Natural }, quorumThreshold : Cardano.Utils.UnitInterval }"]],["NewConstitution",["Cardano.Gov.Constitution"]],["Info",[]]]},{"name":"CertificateIntent","comment":" All intents requiring the on-chain publication of a certificate.\n\nThese include stake registration and delegation,\nstake pool management, and voting or delegating your voting power.\n\n","args":[],"cases":[["RegisterStake",["{ delegator : Cardano.Witness.Credential, deposit : Natural.Natural }"]],["UnregisterStake",["{ delegator : Cardano.Witness.Credential, refund : Natural.Natural }"]],["DelegateStake",["{ delegator : Cardano.Witness.Credential, poolId : Bytes.Comparable.Bytes Cardano.Pool.Id }"]],["RegisterPool",["{ deposit : Natural.Natural }","Cardano.Pool.Params"]],["RetirePool",["{ poolId : Bytes.Comparable.Bytes Cardano.Pool.Id, epoch : Natural.Natural }"]],["RegisterDrep",["{ drep : Cardano.Witness.Credential, deposit : Natural.Natural, info : Maybe.Maybe Cardano.Gov.Anchor }"]],["UnregisterDrep",["{ drep : Cardano.Witness.Credential, refund : Natural.Natural }"]],["VoteAlwaysAbstain",["{ delegator : Cardano.Witness.Credential }"]],["VoteAlwaysNoConfidence",["{ delegator : Cardano.Witness.Credential }"]],["DelegateVotes",["{ delegator : Cardano.Witness.Credential, drep : Cardano.Address.Credential }"]]]},{"name":"Fee","comment":" Configure fees manually or automatically for a transaction.\n","args":[],"cases":[["ManualFee",["List.List { paymentSource : Cardano.Address.Address, exactFeeAmount : Natural.Natural }"]],["AutoFee",["{ paymentSource : Cardano.Address.Address }"]]]},{"name":"SpendSource","comment":" Represents different sources for spending assets.\n","args":[],"cases":[["FromWallet",["{ address : Cardano.Address.Address, value : Cardano.Value.Value, guaranteedUtxos : List.List Cardano.Utxo.OutputReference }"]],["FromNativeScript",["{ spentInput : Cardano.Utxo.OutputReference, nativeScriptWitness : Cardano.Witness.NativeScript }"]],["FromPlutusScript",["{ spentInput : Cardano.Utxo.OutputReference, datumWitness : Maybe.Maybe (Cardano.Witness.Source Cardano.Data.Data), plutusScriptWitness : Cardano.Witness.PlutusScript }"]]]},{"name":"TxFinalizationError","comment":" Errors that may happen during Tx finalization.\n","args":[],"cases":[["UnableToGuessFeeSource",[]],["UnbalancedIntents",["{ inputTotal : Cardano.Value.Value, outputTotal : Cardano.Value.Value, extraneousInput : Cardano.Value.Value, extraneousOutput : Cardano.Value.Value }","String.String"]],["InsufficientManualFee",["{ declared : Natural.Natural, computed : Natural.Natural }"]],["NotEnoughMinAda",["String.String"]],["InvalidAddress",["Cardano.Address.Address","String.String"]],["InvalidStakeAddress",["Cardano.Address.StakeAddress","String.String"]],["DuplicateVoters",["List.List { voter : String.String }"]],["EmptyVotes",["{ voter : String.String }"]],["DuplicateMints",["List.List { policyId : String.String }"]],["EmptyMint",["{ policyId : String.String }"]],["WitnessError",["Cardano.Witness.Error"]],["FailedToPerformCoinSelection",["Cardano.CoinSelection.Error"]],["CollateralSelectionError",["Cardano.CoinSelection.Error"]],["DuplicatedMetadataTags",["Basics.Int"]],["IncorrectTimeValidityRange",["String.String"]],["UplcVmError",["String.String"]],["GovProposalsNotSupportedInSimpleFinalize",[]],["FailurePleaseReportToElmCardano",["String.String"]]]},{"name":"TxIntent","comment":" Represents different types of transaction intents.\n","args":[],"cases":[["SendTo",["Cardano.Address.Address","Cardano.Value.Value"]],["SendToOutput",["Cardano.Utxo.Output"]],["SendToOutputAdvanced",["Cardano.TxContext.TxContext -> Cardano.Utxo.Output"]],["Spend",["Cardano.TxIntent.SpendSource"]],["MintBurn",["{ policyId : Bytes.Comparable.Bytes Cardano.Address.CredentialHash, assets : Bytes.Map.BytesMap Cardano.MultiAsset.AssetName Integer.Integer, scriptWitness : Cardano.Witness.Script }"]],["IssueCertificate",["Cardano.TxIntent.CertificateIntent"]],["WithdrawRewards",["{ stakeCredential : Cardano.Address.StakeAddress, amount : Natural.Natural, scriptWitness : Maybe.Maybe Cardano.Witness.Script }"]],["Vote",["Cardano.Witness.Voter","List.List Cardano.TxIntent.VoteIntent"]],["Propose",["Cardano.TxIntent.ProposalIntent"]]]},{"name":"TxOtherInfo","comment":" Represents additional information for a transaction.\n","args":[],"cases":[["TxReferenceInput",["Cardano.Utxo.OutputReference"]],["TxMetadata",["{ tag : Natural.Natural, metadata : Cardano.Metadatum.Metadatum }"]],["TxTimeValidityRange",["{ start : Basics.Int, end : Natural.Natural }"]]]}],"aliases":[{"name":"GovernanceState","comment":" Contains pointers to the latest enacted governance actions and to the constitution.\n","args":[],"type":"{ guardrailsScript : Maybe.Maybe { policyId : Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId, plutusVersion : Cardano.Script.PlutusVersion, scriptWitness : Cardano.Witness.Source (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor) }, lastEnactedCommitteeAction : Maybe.Maybe Cardano.Gov.ActionId, lastEnactedConstitutionAction : Maybe.Maybe Cardano.Gov.ActionId, lastEnactedHardForkAction : Maybe.Maybe Cardano.Gov.ActionId, lastEnactedProtocolParamUpdateAction : Maybe.Maybe Cardano.Gov.ActionId }"},{"name":"ProposalIntent","comment":" Governance action proposal.\n","args":[],"type":"{ govAction : Cardano.TxIntent.ActionProposal, offchainInfo : Cardano.Gov.Anchor, deposit : Natural.Natural, depositReturnAccount : Cardano.Address.StakeAddress }"},{"name":"TxFinalized","comment":" Result of the Tx finalization.\n\nThe hashes of the credentials expected to provide a signature\nare provided as an additional artifact of Tx finalization.\n\n","args":[],"type":"{ tx : Cardano.Transaction.Transaction, expectedSignatures : List.List (Bytes.Comparable.Bytes Cardano.Address.CredentialHash) }"},{"name":"VoteIntent","comment":" Governance vote.\n","args":[],"type":"{ actionId : Cardano.Gov.ActionId, vote : Cardano.Gov.Vote, rationale : Maybe.Maybe Cardano.Gov.Anchor }"}],"values":[{"name":"balance","comment":" Attempt to balance a transaction with a provided address.\n\nAll the missing value from inputs and/or outputs is compensated\nby adding new intents with the provided address as source and/or destination.\n\nThe function may fail while verifying that all references are present in the local state UTxOs.\n\n","type":"Cardano.Utxo.RefDict Cardano.Utxo.Output -> Cardano.Address.Address -> List.List Cardano.TxIntent.TxIntent -> Result.Result Cardano.TxIntent.TxFinalizationError (List.List Cardano.TxIntent.TxIntent)"},{"name":"emptyGovernanceState","comment":" Just a helper initialization for when we don’t care about governance proposals.\n","type":"Cardano.TxIntent.GovernanceState"},{"name":"errorToString","comment":" Provide a default function to convert an error to a human-readable string.\n","type":"Cardano.TxIntent.TxFinalizationError -> String.String"},{"name":"finalize","comment":" Finalize a transaction before signing and submitting it.\n\nAnalyze all intents and perform the following actions:\n\n  - Check the Tx balance\n  - Select the input UTxOs with a default coin selection algorithm\n  - Evaluate script execution costs with default mainnet parameters\n  - Try to find fee payment source automatically and compute automatic Tx fee\n\nThe network parameters will be automatically chosen to be:\n\n  - default Mainnet parameters if the guessed fee address is from Mainnet\n  - default Preview parameters if the guessed fee address is from a testnet.\n\nPreprod is not supported for this simplified [finalize] function.\nIn case you want more customization, please use [finalizeAdvanced].\n\n","type":"Cardano.Utxo.RefDict Cardano.Utxo.Output -> List.List Cardano.TxIntent.TxOtherInfo -> List.List Cardano.TxIntent.TxIntent -> Result.Result Cardano.TxIntent.TxFinalizationError Cardano.TxIntent.TxFinalized"},{"name":"finalizeAdvanced","comment":" Finalize a transaction before signing and submitting it.\n\nAnalyze all intents and perform the following actions:\n\n  - Check the Tx balance\n  - Select the input UTxOs with the provided coin selection algorithm\n  - Evaluate script execution costs with the provided function\n  - Compute Tx fee if set to auto\n\n","type":"{ govState : Cardano.TxIntent.GovernanceState, localStateUtxos : Cardano.Utxo.RefDict Cardano.Utxo.Output, coinSelectionAlgo : Cardano.CoinSelection.Algorithm, evalScriptsCosts : Cardano.Utxo.RefDict Cardano.Utxo.Output -> Cardano.Transaction.Transaction -> Result.Result String.String (List.List Cardano.Redeemer.Redeemer), costModels : Cardano.Gov.CostModels } -> Cardano.TxIntent.Fee -> List.List Cardano.TxIntent.TxOtherInfo -> List.List Cardano.TxIntent.TxIntent -> Result.Result Cardano.TxIntent.TxFinalizationError Cardano.TxIntent.TxFinalized"},{"name":"updateLocalState","comment":" Update the known local state with the spent and created UTxOs of a given transaction.\n","type":"Bytes.Comparable.Bytes Cardano.Utxo.TransactionId -> Cardano.Transaction.Transaction -> Cardano.Utxo.RefDict Cardano.Utxo.Output -> { updatedState : Cardano.Utxo.RefDict Cardano.Utxo.Output, spent : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ), created : List.List ( Cardano.Utxo.OutputReference, Cardano.Utxo.Output ) }"}],"binops":[]},{"name":"Cardano.Uplc","comment":" Handling the UPLC VM\n\n@docs evalScriptsCosts, evalScriptsCostsRaw\n\n@docs applyParamsToScript\n\n@docs VmConfig, defaultVmConfig, conwayDefaultBudget, conwayDefaultCostModels\n\n@docs SlotConfig, slotConfigMainnet, slotConfigPreview, slotConfigPreprod\n\n","unions":[],"aliases":[{"name":"SlotConfig","comment":" Time managing config for the VM.\n","args":[],"type":"{ zeroTime : Natural.Natural, zeroSlot : Natural.Natural, slotLengthMs : Basics.Int }"},{"name":"VmConfig","comment":" UPLC VM configuration.\n\nThis is required so that the VM knows how to price memory usage and execution steps,\nas well as how to manage time.\n\n","args":[],"type":"{ budget : Cardano.Redeemer.ExUnits, slotConfig : Cardano.Uplc.SlotConfig, costModels : Cardano.Gov.CostModels }"}],"values":[{"name":"applyParamsToScript","comment":" Apply a list of [Data] encode parameters to a given [PlutusScript].\n\nSimilar to [evalScriptsCostsRaw], This function will call Aiken UPLC VM with\nsome JavaScript and WebAssembly code.\nIt requires customized Elm compilation and JS code patching,\nso you need to call the `elm-cardano` binary for compilation.\nMore info on that in the `README` of the [elm-cardano GitHub repo](https://github.com/elm-cardano/elm-cardano).\n\n","type":"List.List Cardano.Data.Data -> Cardano.Script.PlutusScript -> Result.Result String.String Cardano.Script.PlutusScript"},{"name":"conwayDefaultBudget","comment":" The default budget currently in the Conway era.\n","type":"Cardano.Redeemer.ExUnits"},{"name":"conwayDefaultCostModels","comment":" Default cost models for the Plutus VM currently in the Conway era.\n","type":"Cardano.Gov.CostModels"},{"name":"defaultVmConfig","comment":" Default UPLC VM config.\n","type":"Cardano.Uplc.VmConfig"},{"name":"evalScriptsCosts","comment":" Evaluate Plutus scripts costs.\n\nThis also checks that the provided local state has all relevant UTxOs present.\n\nThis function will call Aiken UPLC VM with some JavaScript and WebAssembly code.\nIt requires customized Elm compilation and JS code patching,\nso you need to call the `elm-cardano` binary for compilation.\nMore info on that in the `README` of the [elm-cardano GitHub repo](https://github.com/elm-cardano/elm-cardano).\n\n","type":"Cardano.Uplc.VmConfig -> Cardano.Utxo.RefDict Cardano.Utxo.Output -> Cardano.Transaction.Transaction -> Result.Result String.String (List.List Cardano.Redeemer.Redeemer)"},{"name":"evalScriptsCostsRaw","comment":" Evaluate plutus scripts costs with the Tx raw bytes.\n\nThis function will call Aiken UPLC VM with some JavaScript and WebAssembly code.\nIt requires customized Elm compilation and JS code patching,\nso you need to call the `elm-cardano` binary for compilation.\nMore info on that in the `README` of the [elm-cardano GitHub repo](https://github.com/elm-cardano/elm-cardano).\n\n","type":"Cardano.Uplc.VmConfig -> Cardano.Utxo.RefDict Cardano.Utxo.Output -> Bytes.Comparable.Bytes any -> Result.Result String.String (List.List Cardano.Redeemer.Redeemer)"},{"name":"slotConfigMainnet","comment":" Default slot config for Mainnet.\n","type":"Cardano.Uplc.SlotConfig"},{"name":"slotConfigPreprod","comment":" Default slot config for Preprod.\n","type":"Cardano.Uplc.SlotConfig"},{"name":"slotConfigPreview","comment":" Default slot config for Preview.\n","type":"Cardano.Uplc.SlotConfig"}],"binops":[]},{"name":"Cardano.Utils","comment":" Just a utility module to avoid cyclic import dependencies.\n\n@docs RationalNumber, UnitInterval, PositiveInterval, decodeRational, encodeRationalNumber\n\n","unions":[],"aliases":[{"name":"PositiveInterval","comment":" Represents a positive interval (> 0).\n","args":[],"type":"Cardano.Utils.RationalNumber"},{"name":"RationalNumber","comment":" Represents a rational number.\n","args":[],"type":"{ numerator : Basics.Int, denominator : Basics.Int }"},{"name":"UnitInterval","comment":" Represents a unit interval (0 to 1).\n","args":[],"type":"Cardano.Utils.RationalNumber"}],"values":[{"name":"decodeRational","comment":" Decoder for RationalNumber type.\n","type":"Cbor.Decode.Decoder Cardano.Utils.RationalNumber"},{"name":"encodeRationalNumber","comment":" Encoder for RationalNumber type.\n","type":"Cardano.Utils.RationalNumber -> Cbor.Encode.Encoder"}],"binops":[]},{"name":"Cardano.Utxo","comment":" Handling outputs.\n\n\n## Definitions\n\n@docs OutputReference, TransactionId, Output, DatumHash, DatumOption\n\n\n## Dictionary with [OutputReference] keys\n\n@docs RefDict, emptyRefDict, refDictFromList\n\n\n## Build\n\n@docs fromLovelace, simpleOutput\n\n\n## Display\n\n@docs refAsString\n\n\n## Query\n\n@docs lovelace, totalLovelace, compareLovelace, isAdaOnly, isAssetsOnly\n\n\n## Compute\n\n@docs minAda, checkMinAda, minAdaForAssets, freeAda, bytesWidth\n\n\n## Convert\n\n@docs encodeOutputReference, encodeOutput, encodeDatumOption\n\n@docs decodeOutputReference, decodeOutput\n\n@docs outputReferenceToData, datumValueFromData\n\n","unions":[{"name":"DatumHash","comment":" Phantom type for 32-bytes datum hashes.\nThis is a Blake2b-256 hash.\n","args":[],"cases":[]},{"name":"DatumOption","comment":" Nickname for data stored in a eUTxO.\n","args":[],"cases":[["DatumHash",["Bytes.Comparable.Bytes Cardano.Utxo.DatumHash"]],["DatumValue",["{ rawBytes : Bytes.Comparable.Bytes Cardano.Data.Data }"]]]},{"name":"TransactionId","comment":" Phantom type for 32-bytes transaction IDs.\nThis is a Blake2b-256 hash.\n","args":[],"cases":[]}],"aliases":[{"name":"Output","comment":" The content of a eUTxO.\n","args":[],"type":"{ address : Cardano.Address.Address, amount : Cardano.Value.Value, datumOption : Maybe.Maybe Cardano.Utxo.DatumOption, referenceScript : Maybe.Maybe Cardano.Script.Reference }"},{"name":"OutputReference","comment":" The reference for a eUTxO.\n","args":[],"type":"{ transactionId : Bytes.Comparable.Bytes Cardano.Utxo.TransactionId, outputIndex : Basics.Int }"},{"name":"RefDict","comment":" Convenience type for `Dict` with [OutputReference] keys.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","args":["a"],"type":"Dict.Any.AnyDict ( String.String, Basics.Int ) Cardano.Utxo.OutputReference a"}],"values":[{"name":"bytesWidth","comment":" Computes the bytes width of the output if we encode it to CBOR.\n","type":"Cardano.Utxo.Output -> Basics.Int"},{"name":"checkMinAda","comment":" Check that an [Output] has enough ada to cover its size.\n","type":"Cardano.Utxo.Output -> Result.Result String.String Cardano.Utxo.Output"},{"name":"compareLovelace","comment":" Compare UTxOs by lovelace value.\n","type":"Cardano.Utxo.Output -> Cardano.Utxo.Output -> Basics.Order"},{"name":"datumValueFromData","comment":" Create a DatumOption with a value from a Data object.\n","type":"Cardano.Data.Data -> Cardano.Utxo.DatumOption"},{"name":"decodeOutput","comment":" CBOR decoder for an [Output].\n","type":"Cbor.Decode.Decoder Cardano.Utxo.Output"},{"name":"decodeOutputReference","comment":" Decode an [OutputReference], such as for transaction inputs.\n","type":"Cbor.Decode.Decoder Cardano.Utxo.OutputReference"},{"name":"emptyRefDict","comment":" Convenience empty initialization for `Dict` with [OutputReference] keys.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"Cardano.Utxo.RefDict a"},{"name":"encodeDatumOption","comment":" CBOR encoder for [DatumOption].\n","type":"Cardano.Utxo.DatumOption -> Cbor.Encode.Encoder"},{"name":"encodeOutput","comment":" CBOR encoder for [Output].\n","type":"Cardano.Utxo.Output -> Cbor.Encode.Encoder"},{"name":"encodeOutputReference","comment":" CBOR encoder for [OutputReference].\n","type":"Cardano.Utxo.OutputReference -> Cbor.Encode.Encoder"},{"name":"freeAda","comment":" Amount of Ada Lovelace \"free\" in the output,\nmeaning the amount above the minimum required for the output.\n","type":"Cardano.Utxo.Output -> Natural.Natural"},{"name":"fromLovelace","comment":" Construct an `Output` from an `Address` and a lovelace amount\n","type":"Cardano.Address.Address -> Natural.Natural -> Cardano.Utxo.Output"},{"name":"isAdaOnly","comment":" Check if the output contains only Ada.\nNothing else is allowed, no tokens, no datum, no ref script.\n","type":"Cardano.Utxo.Output -> Basics.Bool"},{"name":"isAssetsOnly","comment":" Check if the output contains only assets (Ada or tokens).\nDatums and ref scripts are not allowed.\n","type":"Cardano.Utxo.Output -> Basics.Bool"},{"name":"lovelace","comment":" Extract the amount of lovelace in an `Output`\n","type":"Cardano.Utxo.Output -> Natural.Natural"},{"name":"minAda","comment":" Compute minimum Ada lovelace for a given [Output].\n\nSince the size of the lovelace field may impact minAda,\nwe adjust its value if it is too low before computation.\n\nThe formula is given by CIP 55,\nwith current value of `4310` for `coinsPerUTxOByte`.\n\nTODO: provide `coinsPerUTxOByte` in function arguments?\n\n","type":"Cardano.Utxo.Output -> Natural.Natural"},{"name":"minAdaForAssets","comment":" Compute minimum Ada lovelace for a given [MultiAsset] that would be sent to a given address.\n\nTODO: provide `coinsPerUTxOByte` in function arguments?\n\n","type":"Cardano.Address.Address -> Cardano.MultiAsset.MultiAsset Natural.Natural -> Natural.Natural"},{"name":"outputReferenceToData","comment":" [Data] encoder function for [OutputReference].\n","type":"Cardano.Utxo.OutputReference -> Cardano.Data.Data"},{"name":"refAsString","comment":" Display the [OutputReference] as a String.\n","type":"Cardano.Utxo.OutputReference -> String.String"},{"name":"refDictFromList","comment":" Convenience function to create a `Dict` with [OutputReference] keys from a list.\n\nWARNING: do not compare them with `==` since they contain functions.\n\n","type":"List.List ( Cardano.Utxo.OutputReference, a ) -> Cardano.Utxo.RefDict a"},{"name":"simpleOutput","comment":" Create a simple [Output] with just an [Address] and a [Value].\n","type":"Cardano.Address.Address -> Cardano.Value.Value -> Cardano.Utxo.Output"},{"name":"totalLovelace","comment":" Calculate the total number of lovelace in a collection of `Output`\n","type":"List.List Cardano.Utxo.Output -> Natural.Natural"}],"binops":[]},{"name":"Cardano.Value","comment":" Handling Cardano values.\n\n@docs Value, zero, onlyLovelace, onlyToken\n\n@docs add, addTokens, subtract, atLeast, sum, normalize, compare\n\n@docs encode, fromCbor\n\n@docs toMultilineString\n\n","unions":[],"aliases":[{"name":"Value","comment":" A multi-asset output Value. Contains tokens indexed by policy id and asset name.\n\nThis type maintains some invariants by construction.\nIn particular, a Value will never contain a zero quantity of a particular token.\n\nTODO: make sure the previous statement stays true by construction.\nThat would require an opaque type and some property tests.\n\n","args":[],"type":"{ lovelace : Natural.Natural, assets : Cardano.MultiAsset.MultiAsset Natural.Natural }"}],"values":[{"name":"add","comment":" Add the values of two UTxOs together.\n","type":"Cardano.Value.Value -> Cardano.Value.Value -> Cardano.Value.Value"},{"name":"addTokens","comment":" Add some tokens to another [Value].\n","type":"Cardano.MultiAsset.MultiAsset Natural.Natural -> Cardano.Value.Value -> Cardano.Value.Value"},{"name":"atLeast","comment":" Check that some value contains at least some minimum value.\n\n    onlyLovelace Natural.two\n      |> atLeast (onlyLovelace Natural.one)\n      --> True\n\n","type":"Cardano.Value.Value -> Cardano.Value.Value -> Basics.Bool"},{"name":"compare","comment":" Compare by amount of a given token.\n","type":"(Cardano.Value.Value -> Natural.Natural) -> Cardano.Value.Value -> Cardano.Value.Value -> Basics.Order"},{"name":"encode","comment":" CBOR encoder for [Value].\n","type":"Cardano.Value.Value -> Cbor.Encode.Encoder"},{"name":"fromCbor","comment":" CBOR decoder for [Value].\n","type":"Cbor.Decode.Decoder Cardano.Value.Value"},{"name":"normalize","comment":" Remove 0 amounts in non-ada assets.\n","type":"Cardano.Value.Value -> Cardano.Value.Value"},{"name":"onlyLovelace","comment":" Create a [Value] just containing Ada lovelaces.\n","type":"Natural.Natural -> Cardano.Value.Value"},{"name":"onlyToken","comment":" Create a [Value] just from some token amount.\n","type":"Bytes.Comparable.Bytes Cardano.MultiAsset.PolicyId -> Bytes.Comparable.Bytes Cardano.MultiAsset.AssetName -> Natural.Natural -> Cardano.Value.Value"},{"name":"subtract","comment":" subtract the second value from the first one: (v1 - v2).\n\nIt’s a saturating difference, so if the second value is bigger than the first,\nthe difference is clamped to 0.\n\nThe resulting [Value] is not normalized by default.\nSo the result may contain assets with 0 amounts.\nTo remove all 0 amount assets, call [normalize] on the substraction result.\n\n","type":"Cardano.Value.Value -> Cardano.Value.Value -> Cardano.Value.Value"},{"name":"sum","comment":" Sum the values of all tokens.\n","type":"List.List Cardano.Value.Value -> Cardano.Value.Value"},{"name":"toMultilineString","comment":" Helper function to display a `Value`.\n","type":"Cardano.Value.Value -> List.List String.String"},{"name":"zero","comment":" Empty [Value] with 0 ada and no token.\n","type":"Cardano.Value.Value"}],"binops":[]},{"name":"Cardano.Witness","comment":" Handling witnesses for Tx building intents.\n\n@docs Voter, toVoter, Credential, toCredential, Script, NativeScript, PlutusScript, Source, Error, errorToString\n\n@docs credentialIsPlutusScript, mapSource, toHex, sourceToResult, extractRef\n\n@docs checkDatum, checkScript, checkNativeScript, checkPlutusScript\n\n","unions":[{"name":"Credential","comment":" The type of credential to provide.\n\nIt can either be a key, typically from a wallet,\na native script, or a plutus script.\n\n","args":[],"cases":[["WithKey",["Bytes.Comparable.Bytes Cardano.Address.CredentialHash"]],["WithScript",["Bytes.Comparable.Bytes Cardano.Address.CredentialHash","Cardano.Witness.Script"]]]},{"name":"Error","comment":" Error type describing all kind of errors that can happen while validating witnesses.\n","args":[],"cases":[["InvalidExpectedSigners",["{ scriptHash : Bytes.Comparable.Bytes Cardano.Address.CredentialHash }","String.String"]],["ScriptHashMismatch",["{ expected : Bytes.Comparable.Bytes Cardano.Address.CredentialHash, witness : Bytes.Comparable.Bytes Cardano.Address.CredentialHash }","String.String"]],["ExtraneousDatum",["Cardano.Witness.Source Cardano.Data.Data","String.String"]],["MissingDatum",["Bytes.Comparable.Bytes Cardano.Utxo.DatumHash","String.String"]],["DatumHashMismatch",["{ expected : Bytes.Comparable.Bytes Cardano.Utxo.DatumHash, witness : Bytes.Comparable.Bytes Cardano.Utxo.DatumHash }","String.String"]],["ReferenceOutputsMissingFromLocalState",["List.List Cardano.Utxo.OutputReference"]],["MissingReferenceScript",["Cardano.Utxo.OutputReference"]],["InvalidScriptRef",["Cardano.Utxo.OutputReference","Bytes.Comparable.Bytes Cardano.Script.Script","String.String"]]]},{"name":"Script","comment":" Represents different types of script witnesses.\n","args":[],"cases":[["Native",["Cardano.Witness.NativeScript"]],["Plutus",["Cardano.Witness.PlutusScript"]]]},{"name":"Source","comment":" Represents different sources for witnesses.\n","args":["a"],"cases":[["ByValue",["a"]],["ByReference",["Cardano.Utxo.OutputReference"]]]},{"name":"Voter","comment":" Voting credentials can either come from\na DRep, a stake pool, or Constitutional Committee member.\n","args":[],"cases":[["WithCommitteeHotCred",["Cardano.Witness.Credential"]],["WithDrepCred",["Cardano.Witness.Credential"]],["WithPoolCred",["Bytes.Comparable.Bytes Cardano.Address.CredentialHash"]]]}],"aliases":[{"name":"NativeScript","comment":" Represents a Native script witness.\n\nExpected signatures are not put in the \"required\\_signers\" field of the Tx\nbut are still used to estimate fees.\n\nIf you expect to sign with all credentials present in the multisig,\nyou can use `Dict.values (Cardano.Script.extractSigners script)`.\n\nOtherwise, just list the credentials you intend to sign with.\n\n","args":[],"type":"{ script : Cardano.Witness.Source Cardano.Script.NativeScript, expectedSigners : List.List (Bytes.Comparable.Bytes Cardano.Address.CredentialHash) }"},{"name":"PlutusScript","comment":" Represents a Plutus script witness.\n","args":[],"type":"{ script : ( Cardano.Script.PlutusVersion, Cardano.Witness.Source (Bytes.Comparable.Bytes Cardano.Script.ScriptCbor) ), redeemerData : Cardano.TxContext.TxContext -> Cardano.Data.Data, requiredSigners : List.List (Bytes.Comparable.Bytes Cardano.Address.CredentialHash) }"}],"values":[{"name":"checkDatum","comment":" Check that the datum witness matches the output datum option.\n","type":"Cardano.Utxo.RefDict Cardano.Utxo.Output -> Maybe.Maybe Cardano.Utxo.DatumOption -> Maybe.Maybe (Cardano.Witness.Source Cardano.Data.Data) -> Result.Result Cardano.Witness.Error ()"},{"name":"checkNativeScript","comment":" Check the witness of a native script. Both the script hash and the validity of expected signers.\n","type":"Cardano.Utxo.RefDict Cardano.Utxo.Output -> Bytes.Comparable.Bytes Cardano.Address.CredentialHash -> Cardano.Witness.NativeScript -> Result.Result Cardano.Witness.Error ()"},{"name":"checkPlutusScript","comment":" Check the validity of a Plutus script witness.\nWitness sources are checked, script hashes are matched.\n","type":"Cardano.Utxo.RefDict Cardano.Utxo.Output -> Bytes.Comparable.Bytes Cardano.Address.CredentialHash -> Cardano.Witness.PlutusScript -> Result.Result Cardano.Witness.Error ()"},{"name":"checkScript","comment":" Check the witness of a script.\n","type":"Cardano.Utxo.RefDict Cardano.Utxo.Output -> Bytes.Comparable.Bytes Cardano.Address.CredentialHash -> Cardano.Witness.Script -> Result.Result Cardano.Witness.Error ()"},{"name":"credentialIsPlutusScript","comment":" True if the this is a credential witness for a Plutus script.\n","type":"Cardano.Witness.Credential -> Basics.Bool"},{"name":"errorToString","comment":" Convert an error into a human-readable string.\n","type":"Cardano.Witness.Error -> String.String"},{"name":"extractRef","comment":" Extract the [OutputReference] from a witness source,\nif passed by reference. Return [Nothing] if passed by value.\n","type":"Cardano.Witness.Source a -> Maybe.Maybe Cardano.Utxo.OutputReference"},{"name":"mapSource","comment":" Map a function over a witness source (if by value).\n","type":"(a -> b) -> Cardano.Witness.Source a -> Cardano.Witness.Source b"},{"name":"sourceToResult","comment":" Transform a witness source into a Result type.\n\nThis isn’t to semantically say it can fail,\njust to take advantage of all the functions operating on the Result type.\nIn Haskell, we would have converted to Either.\n\n","type":"Cardano.Witness.Source a -> Result.Result a Cardano.Utxo.OutputReference"},{"name":"toCredential","comment":" Helper function to convert a credential witness to an Address.Credential.\n","type":"Cardano.Witness.Credential -> Cardano.Address.Credential"},{"name":"toHex","comment":" Encode a witness source into a unique Hex string representation.\n","type":"(a -> Cbor.Encode.Encoder) -> Cardano.Witness.Source a -> String.String"},{"name":"toVoter","comment":" Helper function to convert a voter to a Gov.Voter.\n","type":"Cardano.Witness.Voter -> Cardano.Gov.Voter"}],"binops":[]},{"name":"Cbor.Decode.Extra","comment":" Extra CBOR decoding utility functions.\n\n@docs set\n@docs natural, integer\n@docs failWith\n\n","unions":[],"aliases":[],"values":[{"name":"failWith","comment":" Helper decoder to display the raw bytes on which the decoder has failed.\n","type":"String.String -> Cbor.Decode.Decoder a"},{"name":"integer","comment":" Decode an unbounded integer.\n","type":"Cbor.Decode.Decoder Integer.Integer"},{"name":"natural","comment":" Decode an unbounded positive integer.\n","type":"Cbor.Decode.Decoder Natural.Natural"},{"name":"set","comment":" Decoder for a set of value. Either an array or within a tag 258.\n\nDon’t ask me why this exists. IOHK designed this standard long ago and wanted to use it.\nRegardless of what the people wanted.\n\nRef: <https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md>\n\n","type":"Cbor.Decode.Decoder a -> Cbor.Decode.Decoder (List.List a)"}],"binops":[]},{"name":"Cbor.Encode.Extra","comment":" Extra CBOR encoding utility functions.\n\n@docs natural, integer\n@docs nonEmptyField\n@docs associativeList, indefiniteList, beginBytes\n\n","unions":[],"aliases":[],"values":[{"name":"associativeList","comment":" Encode associative list with canonical ordering of the keys.\n\nThe keys in every map must be sorted lowest value to highest.\nSorting is performed on the bytes of the representation of the key\ndata items without paying attention to the 3/5 bit splitting for\nmajor types. (Note that this rule allows maps that have keys of\ndifferent types, even though that is probably a bad practice that\ncould lead to errors in some canonicalization implementations.)\nThe sorting rules are:\n\n  - If two keys have different lengths, the shorter one sorts\n    earlier;\n\n  - If two keys have the same length, the one with the lower value\n    in (byte-wise) lexical order sorts earlier.\n\n","type":"(k -> Cbor.Encode.Encoder) -> (v -> Cbor.Encode.Encoder) -> List.List ( k, v ) -> Cbor.Encode.Encoder"},{"name":"beginBytes","comment":" If you really need to build bytes with indefinite arrays.\n","type":"Cbor.Encode.Encoder"},{"name":"indefiniteList","comment":" If you really need indefinite lists.\n","type":"(a -> Cbor.Encode.Encoder) -> List.List a -> Cbor.Encode.Encoder"},{"name":"integer","comment":" Encode a large integer number.\n","type":"Integer.Integer -> Cbor.Encode.Encoder"},{"name":"natural","comment":" Encode a natural number.\n","type":"Natural.Natural -> Cbor.Encode.Encoder"},{"name":"nonEmptyField","comment":" Encode a foldable only if non empty.\n","type":"k -> (field -> Basics.Bool) -> (field -> Cbor.Encode.Encoder) -> (record -> field) -> Cbor.Encode.Step k record -> Cbor.Encode.Step k record"}],"binops":[]},{"name":"RationalNat","comment":" Unbounded positive rational numbers,\nbased on [Natural] numbers for the fraction.\n\n@docs RationalNat\n\n@docs zero, fromSafeInt\n\n@docs add, mul, floor\n\n","unions":[],"aliases":[{"name":"RationalNat","comment":" Unbounded positive rational numbers,\nbased on [Natural] numbers for both sides of the fraction.\n","args":[],"type":"{ num : Natural.Natural, denom : Natural.Natural }"}],"values":[{"name":"add","comment":" Addition\n\nRemark that the denominator part will grow due to exact computation.\nNot simplification is performed.\n\n","type":"RationalNat.RationalNat -> RationalNat.RationalNat -> RationalNat.RationalNat"},{"name":"floor","comment":" Return the integer part of that rational number.\n\nReturn [Nothing] if the denominator is 0.\n\n","type":"RationalNat.RationalNat -> Maybe.Maybe Natural.Natural"},{"name":"fromSafeInt","comment":" Convert from a safe JS integer (< 2^53) to [RationalNat],\nusing 1 for the denominator.\n\nThis has the same limitations than the [Natural] function with the same name.\n\n","type":"Basics.Int -> RationalNat.RationalNat"},{"name":"mul","comment":" Multiplication\n\nRemark that the denominator part will grow due to exact computation.\nNot simplification is performed.\n\n","type":"RationalNat.RationalNat -> RationalNat.RationalNat -> RationalNat.RationalNat"},{"name":"zero","comment":" 0\n","type":"RationalNat.RationalNat"}],"binops":[]},{"name":"Word7","comment":" Decoding 7-bits words.\n\n@docs fromBytes\n\n","unions":[],"aliases":[],"values":[{"name":"fromBytes","comment":" Decode a 7-bit encoded integer\n","type":"Bytes.Decode.Decoder Basics.Int"}],"binops":[]}]